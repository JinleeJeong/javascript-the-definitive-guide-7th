# 4장. 표현식과 연산자

표현식이란 어떤 값으로 평가(evaluate)되는 구절

단순한 표현식을 조합해 복잡한 표현식을 만들 때 연산자 사용

연산자는 피연산자(보통 두 개)의 값을 어떤 형태로 조합해 새 값으로 평가한다

값으로 ‘평가’된다 대신 연산자가 값을 ‘반환’한다고 단순화해서 표현할 때도 있다

## 4.1 기본표현식

가장 단순한 표현식을 기본 표현식

- 리터럴은 문자 그대로 쓰는 값

```jsx
1.23 // 숫자 리터럴
"hello" // 문자열 리터럴
/pattern/ // 정규 표현식 리터럴
```

- 예약어

```jsx
true; // 불 true로 평가됩니다.
false; // 불 false로 평가됩니다.
null; // null로 평가됩니다.
this; // '현재, 객체로 평가됩니다.
```

메서드 바디에서 this는 해당 메서드를 호출한 객체로 평가

- 변수, 상수, 전역 객체의 프로퍼티에 대한 참조 형태

```jsx
i; // 변수 i의 값으로 평가됩니다.
sum; // 변수 sum의 값으로 평가됩니다.
undefined; // 전역 객체의 "undefined" 프로퍼티 값
```

자바스크립트는 프로그램에 있는 식별자를 변수, 상수, 또는 전역 객체의 프로퍼티 라고 가정하고 그 값을 찾는다

그런 이름의 변수가 존재하지 않는다면 존재하지 않는 변수를 평가하려는 시도이므로 ReferenceError가 일어난다

## **4.2** 객체와 배열 초기화 표현식

객체와 배열의 초기화 표현식(initializer)은 그 값이 새로 생성된 객체나 배열인 표현식

이런 초기화 표현식을 객체 리터럴이나 배열 리터럴이라고 부르기도 함

리터럴과 달리 초기화 표현식은 프로퍼티와 요소 값을 지정하는 다양한 하위 표현식으로 구성되므로 기본 표현식은 아니다

**배열 초기화 표현식**

대괄호 안에 콤마로 구분된 리스트를 쓰는 형태의 표현식

배열 초기화 표현식의 값은 새로 생성된 배열

새 배열의 요소는 콤마로 구분된 표현식들의 값으로 초기화된다

배열 초기화 표현식 내부의 요소 표현식 역시 배열 초기화 표현식이 될 수 있다

배열 리터럴에서 콤마 사이 의 값을 생 략하면 정 의 되지 않은 요소가 그 자리에 들어간다

```jsx
let sparseArray = [1,,,,5];
```

마지막에 콤마 있으면 정의되지 않은 요소가 만들어지지는 않음

마지막 표현식 다음의 인덱스에 접근하면 undefined

**객체 초기화 표현식**

대괄호 대신 중괄호 사용

각 하위 표현식은 프로퍼티 이름과 콜론(:) 으로 시작

```jsx
letp={x:2.3,y:-1.2}; //프로퍼티가두개있는객체
let q = {}; // 프로퍼티가 없는 빈 객체
q.x = 2.3; q.y = -1.2; // 이제 q의 프로퍼티는 p의 프로퍼티와 같습니다.

// 중첩도 가능
let rectangle = {
	upperLeft: { x: 2, y: 2 }, 
	lowerRight: { x: 4, y: 5 }
};
```

## **4.3** 함수 정의 표현식

함수 정의 표현식은 함수를 정의하며 그 값은 함수다

함수 정의 표현식을 ‘함수 리터럴’이라고 부른다

```jsx
// 이 함수는 전달받은 값의 제곱을 반환합니다.
let square = function(x) { return x * x; };
```

## **4.4** 프로퍼티 접근 표현식

프로퍼티 접근 표현식은 객체 프로퍼티나 배열 요소의 값으로 평가된다

```jsx
expression.identifier
expression[expression]
```

.이나 [ 앞에 있는 표현식을 첫 번째 로 평가한다

그 값이 null이나 undefined이면 TypeError를 일으킨다

.식별자 문법이 더 간결하긴 하지만, 접근하고자 하는 이름이 유효한 식별자이고 그 이름을 알고 있을 때만 사용할 수 있다

프로퍼티 이름에 스페이스나 구두 점이 들어 있거나, 숫자인 경우(배열), 프로퍼티 이름이 고정되어 있지 않고 계산 결과일 때에는 반드시 대괄호 표기법 사용

### **4.4.1** 조건부 프로퍼티 접근

옵션 체인

a?.b

a가 null이거나 undefined라면 이 표현식은 프로퍼티 b에 접근하려는 시도 없이 undefined로 평가된다

a가 다른 값이라면 a?.b는 a.b처럼 평가된다 (a에 b프로퍼티가 없으면 undefined로 평가)

```jsx
let a = { b: null };
a.b?.c.d // => undefined
```

a는 객체이므로 a.b는 유효한 프로퍼티 접근 표현식

a.b의 값은 null이므로 a.b.c는 TypeError

a.b?.c는 undefined로 평가됨

(a.b?.c).d는 TypeError를 일으킴

a.b?.c.d(괄호 없는 형태)는 undefined로 평가됨

?•의 왼쪽에 있는 하위 표현식이 null이나 undefined로 평가되면 더는 프로퍼티에 접근하려 시도하지 않고 전체표현식을 즉시 undefined로 평가함

[] 대신 ?.[]를 사용하는 조건부 프로퍼티 접근도 있다. a?.[b][c]

```jsx
let a; // 변수 초기화를 깜빡했습니다. 
let index = 0;
try {
	a[index++]; // TypeError가 일어납니다. 
} catch(e) {
	index // => 1: index는 TypeError가 일어나기 전에 증가했습니다. 
}
a?.[index++] // => undefined: a가 정의되지 않았습니다.
index // => 1: ?. []는 단축 평가이므로 index는 증가하지 않았습니다.
a[index++] // TypeError. 정의되지 않은 것에서 인덱스를 찾을 수 없습니다.
```

### 4.5 호출 표현식

호출 표현식은 함수나 메서드를 호출(실행)하는 문법

```jsx
f(0) // f는 함수 표현식이고 0은 인자 표현식입니다. 
Math.max(x,y,z) // Math.max는 함수이고 x, y, z는 인자입니다. 
a.sort() // a.sort는 함수이고 인자는 없습니다.
```

호출 표현식 맨 앞에 있는 표현식이 프로퍼티 접근 표현식 이라면 메서드 호출

### **4.5.1** 조건부호출

조건부 프로퍼티 접근과 마찬가지

before

```jsx
function square(x, log) { // 두 번째 인자는 선택 사항인 함수입니다.
	if (log) { // 선택 사항인 함수 인자를 받았습니다.
		log(x); // 호출합니다.
	}
	return x * x; // 인자의 제곱을 반환합니다.
} 
```

after

```jsx
function square(x, log) { // 두 번째 인자는 선택 사항인 함수입니다. 
	log?.(x); // 함수를 받았으면 호출합니다.
	return x * x; // 인자의 제곱을 반환합니다.
}
```

?.()는 왼쪽에 있는 것이 null이나 undefined인지만 체크한다

```jsx
o.m() // 일반적인 프로퍼티 접근, 일반적인 호출 
o?.m() // 조건부 프로퍼티 접근, 일반적인 호출 
o.m?.() // 일반적인 프로퍼티 접근, 조건부 호출
```

첫 번째 표현식에서 o는 반드시 객체여야 하고, m 프로퍼티가 있어야 하며, 그 프로퍼티의 값도 반드시 함수여야 합니다. 

두 번째 표현식에서 o가 null이나 undefined 라면 전체 표현식은 undefined로 평가됩니다. o가 null이나 undefined가 아니라면 반드시 m프로퍼티가 있어야 하고 그 값은 반드시 함수여야 합니다. 

세 번째 표현식에서 o는 반드시 null이나 undefined가 아니어야 합니다. o에 m 프로퍼티가 없거나 그 프로퍼티 값이 null이라면 전체 표현식이 undefined로 평가됩니다.

### **4.6** 객체 생성 표현식

객체 생성 표현식은 객체를 생성하고 함수(생성자)를 호출해 객체 프로퍼티를 초기화한다

객체 생성 표현식은 호출 표현식과 같지만, 그 앞에 new 키워드를 붙인다는 점이 다르다

```jsx
new Object()
new Point(2,3)

// 생성자 함수에 전달할 인자가 없다면 빈 괄호 생략 가능
new Object 
new Date
```

객체 생성 표현식의 값은 새로 생성된 객체

## **4.7** 연산자 개요

표 4-1 자바스크립트 연산자 참조

### **4.7.1** 피연산자 개수

연산자는 예상하는 피 연산자 개수(항(arity))를 기준으로 분류할 수 있다

단항 연산자

표현식 하나를 다른 표현식으로 변환

ex) -x의 -는 x의 부호를 바꿈

2항 연산자

대부분은 표현식 두 개를 조합해 하나로 만듦

3항 연산자

?: 조건 연산자. 표현식 세 개를 하나로 바꿈

### **4.7.2** 피연산자와 결과 타입

- 값의 타입에 관계없이 동작하는 연산자도 있지만, 대부분은 피 연산자가 특정 타입일 것으로 간주하며 특정 타입의 값을 반환한다
- + 연산자

피연산자가 숫자이면 더하고, 문자열이면 병함

- 비교 연산자

타입에 따라 숫자 순서로도, 알파벳 순서로도 비교할 수 있다

### **4.7.3** 연산자와 부수 효과

- 이후의 평가 결과에 영향을 미치는 부수 효과(side effect)
- 할당 연산자

변수나 프로퍼티에 값을 할당하면 해당 변수나 프로퍼티를 사용하는 모든 표현식에 영향을 미친다

- 증가 연산자 ++와 감소 연산자 一
- delete 연산자

프로퍼티를 삭제하는 것은 해당 프로퍼티에 undefined를 할 당하는 것과 비슷하다(완전히 같지는 않지만)

### **4.7.4** 연산자 우선순위

연산자 우선순위는 동작 순서를 결정한다

우선순위가 높은 연산자는 우선순위가 낮은 연산자보다 먼저 실행된다

괄호를 사용해서 연산자 우선순위를 덮어쓸 수 있다

곱셈과 나눗셈은 덧셈과 뺄셈보다 우선순위가 높다

할당은 우선순위가 아주 낮으며 거의 항상 마지막에 수행 된다

ES2020은 ??를 &&나 ||와 함께 사용할 때 명시적으로 괄호를 사용할 것을 요구

*와 단항 부정(-) 연산자도 마찬가지로 괄호 요구

### **4.7.5** 연산자 결합성

연산자의 결합성은 우선순위가 같은 동작을 수행할 때의 순서

- 뺄셈은 좌결합성
    - 지수, 단항, 할당, 조건(3항) 연산자는 오른쪽에서 왼쪽으로 수행

```jsx
w = x - y - z; 는
w = ((x - y) - z); 와 동일

y = a ** b ** c;
x = ~—y;
w = x = y = z;
q = a?b:c?d:e?f:g;
는

y = (a ** (b ** c));
x = ~(-y);
w = (x = (y = z));
q = a?b:(c?d:(e?f:g));
와 동일
```

### **4.7.6** 평가 순서

항상 표현식을 왼쪽에서 오른쪽으로 평가

w = x + y * z 에서

하위 표현식 w를 첫 번째 평가하고, 그 다음 x, y, 그를 순서대로 평가한다
그런 다음 y와 그의 값을 곱하고, x의 값을 더한 다음 표현식 w에서 지정한 변수나 프로퍼티에 할당

## **4.8** 산술 표현식

기본 산술 연산자에는 **(지수), *(곱셈), /(나눗셈), %(나머지), +(덧셈), -(뺄셈)

피연산자를 평가해서 필요하다면 숫자로 변환한 다음 제 곱, 곱, 몫, 나머지, 차이를 계산

숫자가 아니며 숫자로 변환할 수도 없는 피연산자는 NaN 값으로 변환된다

피연산자 중 하나가 NaN이거나 NaN으로 변환된다면 연산 결과는 (거의) 항상 NaN

- * 연산자는 *, /, 잉보다 우선순위가 높으며 , 세 연산자는 다시 +, -보다 우선순위가 높다
    - *는 오른쪽에서 왼쪽으로 동작
    - 2**2**3 은 4**3이 아니라 2**8
    - Math.pow()와 동일
- / 연산자는 첫 번째 피 연산자를 두 번째 피 연산자로 나눈다
    - 모든 숫자가 부동 소수점이므로 나눗셈의 결과 역시 항상 부동 소수점
    - 5/2은 2가 아 니라 2.5
- % 연산자는 첫 번째 피연산자를 두 번째 피연산자로 나눈 나머지
    - 부호는 첫 번째 피연산자를 따름
    - 5 % 2는1이고,-5 % 2는-1
- 부동소수점 값도 사용할 수 있다
    - 6.5 % 2.1는 0.2

### **4.8.1** +연산자

- 숫자 피연산자는 더하고 문자열 피연산자는 병합한다

```jsx
1+2 // => 3
"hello" + " " + "there" // => "hello there"
"1" + "2" // => "12"
```

- 문자열 병합에 우선순위가 있다
- 피연산자 중 하나가 객체라면 3.9.3절에서 설명한 객체에서 기본 값으로 변환하 는 알고리즘을 사용해 기본 값으로 변환한다. Date 객체는 toString() 메서드를 호출하며 다른 객체는 valueOf() 메서드(그 메서드가 기본 값을 반환한다면) 를 호출한다. 하지만 대부분의 객체에서 valueOf() 메서드는 그리 유용하지 않으므로 대개는 toString()이 호출된다.
- 객체에서 기본 값으로 변환하고 난 뒤 피연산자 중 하나가 문자열이면 다른 하 나를 문자열로 변환한 다음 병합합니다.
- 둘 다 문자열이 아니라면 숫자(또는 NaN)로 변환한 후 더합니다.

```jsx
1+2 //=>3:덧셈
"1" + "2" // => "12": 병합
"1" + 2 // => "12": 숫자를 문자열로 변환한 후 병합
1 + {} // => "1 [object Object]": 객체를 문자열로 변환한 후 병합
true + true //=>2: 불값을 숫자로 변환한 후 덧셈
2 + null  //=>2: null을 0으로 변환한 후 덧셈
2 + undefined // => NaN: undefined를 NaN으로 변환한 후 덧셈
```

### **4.8.2** 단항 산술 연산자

단항 연산자는 피 연산자 하나의 값을 바꿔 새 값을 얻는다

모두 우선순위가 높으며 전부 오른쪽에서 왼쪽으로 연산을 수행한다

+, ++, --

피연산자를 숫자로 변환

+, -는 단항 연산자로도, 2항 연산자로도 사용된다

- 단항 플러스(+)
    - 피연산자를 숫자(또는 NaN)로 변환한 값을 반환
    - BigInt값은 숫자로 변환할 수 없으므로 사용 불가
- 단항 마이너스(-)
    - 피연산자를 숫자로 변환한 다음 부호를 바꾼다
- 증가(++)
    - 피연산자를 숫자로 변환하고 1을 더한 다음 증가된 값을 다시 피연산자에 할당한다
    - 전위 증가 연산자 (피연산자 앞에 ++ 있음) : 피 연산 자의 값에 1을 더한 다음, 그 값으로 평가됨
    - 후위 증가 연산자 (피연산자 뒤에 ++ 있음) : 피 연산 자의 값에 1을 더한 다음, 더하기 전의 값으로 평가됨
    
    ```jsx
    let i = 1, j = ++i; // i와 느는 모두 2입니다.
    let n = 1, m = n++; // * 2이고 m은 1입니다.
    ```
    
    - 표현식 x++가 항상 x=x+1과 같은 건 아니다
        - ++ 연산자는 절대 문자열 병합을 수행하지 않는다
        - x가 문자열 “1”이라면 ++x는 숫자 2지만, x+1은 문자열 “11”이다
    - 자동 세미콜론 삽입 기능이 있어 연산자 사이에서 줄을 바꿀 수 없다
    - for문에서 카운터를 1 증가시키는 목적으로 가장 많이 사용

- 감소 (--)
    - 증가와 마찬가지

### **4.8.3** 비트 연산자

추후 작성...

## **4.9** 관계 표현식

관계 연산자는 두 값 사 이의 관계(‘동둥하다’, 보다 작다’, 의 프로퍼티’)를 나타낸다

false 또는 true를 반환

불 값으로 평가됨

if, while, for 같은 제어문에 사용

### **4.9.1** 일치와 불일치 연산자

- 일치 연산자 (===) : 엄격한 정의에 따라 두 피연산자가 ‘완전히’ 일치하는지 체크
- 동등 연산자 (==) : 값을 비교할 때 타입 변환을 허용하므로 두 피연산자가 ‘같다고 볼 수 있는지’ 체크
- 불일치 연산자 (!==)
- 비동등 연산자 (≠)

객체는 값이 아니라 참조로 비교한다

객체는 자기 자신과 같지만, 다른 어떤 객체와도 같지 않다

별개의 두 객체가 프로퍼티 숫자도 같고, 이름과 값까지 같다 하더라도 둘은 다른 객체이다

마찬가지로, 두 배열이 같은 요소를 같은 순서로 포함하고 있어도 서로 다른 배열이다

**일치**

일치 연산자 ===는 먼저 피연산자를 평가한 다음, 두 값을 다음과 같이 비교하되, 타입 변환은 수행하지 않는다.

- 두 값이 다른 타입이면 같은 값이 아니다.
- 두 값이 모두 null이거나 모두 undefined이면 같은 값이다.
- 두 값이 모두 불 값 true거나 불 값 false이면 같은 값이다.
- 두 값 중 하나라도 NaN이면 같은 값이 아니다. 의아할 수 있지만, NaN은 자기 자신을 포함해 어떤 값과도 같지 않다. 값 x가 NaN인지 체크하려면 x !== x를 쓰거나 전역 함수 isNaN()을 써야한다.
- 두 값이 모두 숫자이고 값이 같다면 같은 값이다. 하나가 0이고 다른 하나가 -0이라면 역시 같은 값이다.
- 두 값이 모두 문자열이고 같은 위치에 정확히 같은 16비트 값을 포함한다면(3.3절 참고) 같은 값이다. 문자열의 길이나 내용이 다르다면 같은 값이 아니다. 두 문자열의 의미가 같고 눈으로 보기에 같더라도 내부 표현인 16비트 값은 서로 다를 수 있다. 자바스크립트는 유니코드 정규화를 수행하지 않으므로 이런 문자열은 ===에서도, == 연산자에서도 다르다고 판단한다.
- 두 값이 같은 객체, 배열, 함수를 참조한다면 같은 값이다. 다른 객체를 참조한다면 같은 값이 아니다. 설령 두 객체의 프로퍼티가 일치한다 해도 같은 값이 아니다.

**동등성과 타입 변환**

두 피연산자가 같은 타입이 아니라면 이 연산자는 타입을 변환한 뒤 다음과 같이 비교를 시도

- 두 값이 같은 타입이라면 위에서 설명한 대로 일치하는지 체크한다. 두 값이 일치한다면 같은 값이다. 일치하지 않는다면 같은 값이 아니다.
- 두 값이 같은 타입이 아니더라도 == 연산자는 두 값이 같다고 판단할 수 있다. 동등 연산자는 다음 규칙과 타입 변환을 통해 같은 값인지 체크한다.
    - 하나가 null이고 다른 하나가 undefined이면 같은 값입니다.
    - 하나가 숫자이고 다른 하나가 문자열이라면 문자열을 숫자로 변환하고, 변환된 값을 사용해 다시 비교한다
    - 값 중 하나가 true면 1로 변환한 후 다시 비교합니다. 값 중 하나가 false이면 0으로 변환한 후 다시 비교한다
    - 값 중 하나가 객체이고 다른 값이 숫자나 문자열이면 3.9.3절에서 설명한 알고리즘에 따라 객체를 기본 값으로 변환한 후 다시 비교한다. 객체는 toString() 메서드 또는 valueOf() 메서드를 통해 기본 값으로 변환된다다. 코어 자바스크립트의 내장 클래스는 toString() 변환보다 먼저 valueOf() 변환을 시도하는데, Date 클래스는 예외이며 이 클래스는 toString() 변환을 사용한다.
    - 그외에는모두 다른값
    
    ex)
    
    ```jsx
    "1" == true // => true
    ```
    
    불 값을 숫자로 변환한 후 다시 비교
    
    문자열 “1”을 숫자 1로 변환
    
    두 값은 같은 값이므로 true를 반환
    

### **4.9.2** 비교 연산자

피 연산자의 순서(숫자 또는 알파벳)를 비교

미만(<)

초과 (>)

이하 (<=)

이상(>=)

비교 연산자는 피연산자의 타입을 가리지 않는다. 비교는 숫자와 문자열에 대해서만 가능하므로, 피연산자는 숫자나 문자열로 변환

비교와 변환은 다음과 같이 이루어진다

- 피연산자 중 하나가 객체로 평가되면 그 객체를 3.9.3절에서 설명한 대로 기본 값으로 변환한다. valueOf() 메서드가 기본 값을 반환하면 그 값을 사용한다. 그렇지 않다면 toString() 메서드의 반환 값을 사용한다.
- 객체를 기본 값으로 변환한 후, 두 피연산자가 모두 문자열이라면 두 문자열을 알파벳 순서로 비교한다. 여기서 ‘알파벳 순서’란 문자열을 구성하는 16비트 유니코드 값의 숫자 순서다.
- 객체를 기본 값으로 변환한 결과, 문자열이 아닌 피연산자가 있다면 두 피 연산자를 숫자로 변환한 후 비교한다. 0과 -0은 같은 값으로 간주한다. Infinity 는 자기 자신을 제외한 어떤 값보다 크고, -Infinity는 자기 자신을 제외한 어떤 값보다 작다. 두 피 연산자 중 하나라도 NaN이거나 NaN으로 변환된다면 비교 연산자는 항상 false를 반환한다. 산술 연산자는 Biglnt 값과 일반적인 숫자를 섞어 쓸 수 없지만, 비교 연산자는 숫자와 Biglnt의 비교를 허용한다.

문자열 비교는 대소문자를 구분하며, ASCII 대문자는 모두 ASCII 소문자보다 작다

ex. < 연산자는 문자열 “Zoo”를 문 자열 “aardvark”보다 작다고 판단

**String.localeCompare()**은 해당 지역의 상식에 맞는 알파벳 순서를 판단 기준을 포함

String.toLowerCase(), String.toUpperCase()를 사용해 전부 소문자 또는 대문자로 통일하여 비교 가능

Intl.Collator 클래스를 사용하면 좀 더 상식적인 문자열 비교 결과를 얻을 수 있다

+는 문자열을 선호. 피연산자 중 하나라도 문자열이면 병합하려 함

비교 연산자는 숫자를 선호. 두 피연산자가 모두 문자열일 때만 문자열 비교를 수행

```jsx
1 + 2 // => 3: 덧셈
"1" + "2" // => "12": 병합
"1" + 2 // => "12": 2는 "2"로 변환됩니다.
11 < 3 // => false: 숫자 비교

"11" < "3" // => true: 문자열 비교
"11" < 3 // => false: 숫자 비교."11"은 11로 변환됨
"one" < 3 // => false: 숫자 비교. "one"은 NaN으로 변환됩니다.

```

한 가지 예외는 피연산자 중 하나가 NaN이거나 NaN으로 변환되는 경우, 네 가지 비교 연산자가 모두 false 를 반환

### **4.9.3 in** 연산자

왼쪽 피연산자가 문자열, 심벌, 문자열로 변환될 수 있는 값이라고 예상

오른쪽 피연산자는 객체라고 예상

왼쪽 피연산자가 오른쪽 객체의 프로퍼티 이름일 경우 true를 반환

```jsx
let point = {x: 1, y: 1}; // 객체를 정의합니다.
"x" in point // => true: 객체에는 "x"라는 프로퍼티가 있습니다.
"z" in point // => false: 객체에는 "z"라는 프로퍼티가 없습니다.
"toString" in point // => true: 객체는 toString 메서드를 상속합니다.
 
let data = [7,8,9]; // 프로퍼티(인덱스) 0, 1, 2가 있는 배열
"0" in data // => true: 배열에 요소(인덱스) "0"이 있습니다.
1 in data // => true: 숫자는 문자열로 변환되며 요소(인덱스) "1"이 있습니다.
3 in data // => false: 요소(인덱스) "3"은 없습니다.
```

### **4.9.4 instanceof** 연산자

왼쪽 피연산자가 객체, 오른쪽 피연산자는 객체의 클래스라고 예상

왼쪽에 있는 객체가 오른쪽에 있는 클래스의 인스턴스 라면 true, 그렇지 않다면 false를 반환

자바스크립트 클래스는 초기화 기능이 있는 생성자 함수를 통해 정의되는 객체

instanceof의 오른쪽 피 연산자는 함수여야 한다

```jsx
let d = new Date(); // Date() 생성자로 객체를 생성합니다.
d instanceof Date // => true: d는 Date()를 통해 생성됐습니다.
d instanceof Object // => true: 객체는 모두 Object의 인스턴스입니다. 
d instanceof Number // => false: d는 Number 객체가 아닙니다.
let a = [1, 2, 3]; // 배열 리터럴 문법으로 배열을 생성합니다.
a instanceof Array // => true: a는 배열입니다.
a instanceof Object // => true: 배열은 모두 객체입니다.
a instanceof RegExp // => false: 배열은 정규 표현식이 아닙니다.
```

- 프로토타입 체인

프로토타입 체인은 자바스크립트의 상속 메커니즘

`o instanceof f` 라는 표현식을 평가할 때 먼저 `f.prototype` 을 평가한 후 o의 프로토타입 체인에서 그 값을 찾는다

그런 값을 찾으면 o는 f의 인스턴스(서브클래스)이며 연산자는 true를 반환

o의 프로토타입 체인에 f.prototype이 존재하지 않으면 o는 f의 인스턴스가 아니고, instanceof는 false를 반환

## **4.10** 논리 표현식

### **4.10.1** 불 **AND(&&)**

첫 번째 피 연산자와 두 번째 피 연산자가 모두 true일 때만 true를 반환

피연산자 중 하나라도 false이면 false를 반환

- 두 관계 표현식을 연결하는 용도로도 자주 사용
    - x === 0 && y === 0 // x와 y가 모두 0일 때만 true
- true 같은 값과 false 같은 값 사이에서 불 AND 연산자로 사용된 경우
- 단축 평가(short circuit)
    - 왼쪽에 있는 값이 false 같은 값이면 전체 표현식의 값 역시 반드시 false 같은 값이므로 왼쪽에 있는 값을 반환하며 오른쪽에 있는 표현식을 평가하려 하지도 않는다
    - 왼쪽에 있는 값이 true 같은 값이면 && 연산자는 오른쪽에 있는 값을 평가한 후 반환
    
    ```jsx
    let o = {x: 1};
    let p = null;
    o && o.x // => 1: o는 true 같은 값이므로 o.x의 값을 반환합니다.
    p && p.x // => null: 흐는 false 같은 값이므로 그대로 반환하며 p.x는 평가하지 않습니다.
    ```
    
    - 조건부 수행에 많이 이용
    
    ```jsx
    if (a === b) stop(); // a === b일 때만 stop()을 호출합니다. 
    (a === b) && stop(); // 똑같이 동작합니다.
    ```
    

### **4.10.2** 불 **OR (||)**

두 피연산자 중 하나라도 true 같은 값이면 이 연산자는 true 같은 값을 반환

두 피연산자가 모두 false 같은 값이면 연산자 역시 false 같은 값을 반환

- 단축평가
    - 첫 번째 피연산자의 값이 true 같은 값이면 오른쪽에 있는 표현식은 평가하지 않고 바로 true 같은 값을 반환
    - 첫 번째 피연산자의 값이 false 같은 값이면 II 연산자는 두 번째 피연산자를 평가하고 그 값을 표현식의 값으로 반환
- 몇 가지 변수 중에서 첫 번째로 등장하는 true 같은 값을 선택하려 할 때 자주 사용

```jsx
// maxWidth가 true 같은 값이면 그걸 사용합니다. 그렇지 않다면
// preferences 객체에서 값을 찾습니다. 그 역시 true 같은 값이 아니면 상수 리터럴을 사용합니다. 
let max = maxWidth || preferences.maxWidth || 500;
```

?? 연산자가 대안이 될 수 있음

ES6ㅇ 이후에는 함수 정의 자체에서 함수 매개변수에 기본 값을 설정할 수 있음

### **4.10.3** 불 **NOT (!)**

피연산자의 불 값을 부정하는(반대로 정하는) 것

피연산자를 불값으로 변환한 다음 부정

항상 true 또는 false를 반환

! !x 처럼 이 연산자를 두 번 적용하면 값 x를 그와 동등한 불 값으로 변환

```jsx
// 드 모르간의 법칙
!(p && q) === (!p || !q) // => true: p와 q의 값이 어떻든 관계없습니다.
!(p || q)===(!p && !q) // => true: p와 q의 값이 어떻든 관계없습니다.
```

## **4.11** 할당표현식

변수나 프로퍼티에 값을 할당

왼쪽 피연산자가 왼쪽 값, 즉 변수나 객체 프로퍼티 또는 배열 요소일 것으로 예상

오른쪽 피연산자는 어떤 타입이든, 어떤 값이든 상관없다

오른쪽에 있는 값을 왼쪽에 있는 변수나 프로퍼티 에 할당하므로 나중에 그 변수나 프로퍼티를 참조할 때 지금 할당한 값으로 평가된다

- 할당하는 동시에 테스트할 수 있음
    - (a = b) === 0
- 값 하나를 여러 변수에 할당
    - i = j = k = 0; // 세 변수를 모두 0으로 초기화합니다.

### **4.11.1** 할당과연산

덧셈과 할당을 동시에 수행

```jsx
total += salesTax;
total = total + salesTax;
```

동등하지 않음. 왼쪽에 함수 호출이나 증가 연산자 같은 부수 효과가 있을 때

```jsx
data[i++] *= 2;
data[i++] = data[i++] * 2;
```

## **4.12** 평가 표현식

문자열을 자바스크립트 소스 코드로 해석하고 평가해서 값을 얻을 수 있는 전역함수

```jsx
eval("3+2") // => 5
```

사용자가 입력한 문자열을 eval()에 전달해서는 절대 안된다

일부 웹 서버는 HTTP 콘텐츠 보안 정책 (Content-Security-Policy) 헤더를 통해 웹사이트 전체에서 eval()을 비활성화하기도 한다

### **4.12.1 eval()**

eval()은 인자를 하나 받습니다.

문자열이 아닌 값을 전달하면 그 값을 반환합니 다.

문자열을 전달하면 그 문자열을 자바스크립트 코드로 분석할 수 있는지 시도하고, 실패하면 SyntaxError를 일으킵니다.

문자열을 성공적으로 분석하면 그 코드를 평가하고 해당 문자열의 마지막 표현식 또는 문의 값을 반환하며, 마지막 표현식이나 문에 값이 없다면 undefined를 반환합니다.

평가한 문자열이 예외를 일으키면 그 예외는 eval()을 호출한 호출자로부터 거슬러 올라갑니다.

### **4.12.2** 전역 **eval()**

### **4.12.3** 스트릭트 **eval()**

## **4.13** 기타 연산자

### **4.13.1** 조건 연산자 (?:)

자바스크립트에서 유일한 3항 연산자(피연산자 세 개)

```jsx
x > 0 ? x : -x // x의 절댓값

greeting = "hello" + (username ? username : "there");

greeting = "hello ";
if (username) {
	greeting += username; 
} else {
	greeting += "there"; 
}
```

첫 번째 피연산자의 값이 true 같은 값이면 두 번째 피연산자를 평가하고 그 값을 반환. false 같은 값이면 세 번째 피연산자를 평가하고 그 값을 반환

### **4.13.2 null** 병합 연산자 (??)

null 병합 연산자(first-define operator)

정의된 첫 번째 피연산자로 평가된다

왼쪽 피연산자가 null이나 undefined가 아니면 그 값을 반환

그렇지 않다면 오른쪽 피연산자의 값을 반환

첫 번째 피연산자가 null이나 undefined로 평가될 때만 두 번째 피연산자를 반환

```jsx
a ?? b
(a !== null && a !== undefined) ? a : b
```

```jsx
// maxWidth가 true 같은 값이면 그걸 사용합니다. 그렇지 않다면
// preferences 객체에서 값을 찾습니다. 그 역시 true 같은 값이 아니면 상수 리터럴을 사용합니다. 
let max = maxWidth || preferences.maxWidth || 500;
```

여기서 maxWidth의 값이 0이면 그 값은 무시됨

```jsx
// maxWidth가 정의됐으면 그 값을 사용합니다. 그렇지 않다면
// preferences 객체에서 값을 찾습니다. 그 역시 정의되지 않았다면 상수 리터럴을 사용합니다. 
let max = maxWidth ?? preferences.maxWidth ?? 500;
```

??로 정의하면 0 역시 유효한 값으로 사용할 수 있음

피연산자가 false 같은 값이더라도 정의된 값이기만 하면 ??는 그 값을 반환

첫 번째 피 연산자가 null이나 undefined일 때만 오른 쪽 피 연산자를 평가하고 반환

```jsx
let options = { timeout: 0, title:"", verbose: false, n: null }; 
options.timeout ?? 1000 // => 0: 객체에 정의된 대로
options.title ?? "Untitled" // => "": 객체에 정의된 대로
options.verbose ?? true // => false: 객체에 정의된 대로
options.quiet ?? false // => false: quiet 프로퍼티가 정의되지 않았으므로 오른쪽 값
options.n ?? 10 // => 10: 프로퍼티가 null이므로 오른쪽 값
```

?? 연산자를 사용할 떄 명시적으로 괄호를 써줘야함

```jsx
(a ?? b) || c // ?? => ||
a ?? (b |I c) // || => ??
a ?? b || c // SyntaxError: 괄호가 없습니다.
```

`nullish co-alescing`(null을 병합하는)

필자는 `first-defined`(첫 번째 정의된)라는 이름 사용

이 연산자는 피연산자 중 하나를 선택할 뿐 ‘병합’ 하지는 않는다고 생각하기 때문

### **4.13.3 typeof** 연산자

피연산자의 타입을 나타내는 문자열

typeof는 함수가 아닌 객체 전체와 배열을 뭉뚱그려 “object”라고 평가하므로 객체와 기본 타입을 구별하는 용도로밖에 사용할 수 없음

### **4.13.4 delete** 연산자

피연산자로 지정된 객체 프로퍼티나 배열 요소를 삭제하는 단항 연산자

```jsx
let o = { x: 1, y: 2}; // 이 객체로 시작합니다.
delete o.x; // 프로퍼티 중 하나를 삭제합니다.
"x" in o // => false: 그 프로퍼티는 이제 존재하지 않습니다.

let a = [1,2,3]; // 이 배열로 시작합니다.
delete a[2]; // 배열의 마지막 요소를 삭제합니다.
2 in a // => false: 인덱스 2에 해당하는 요소는 이제 존재하지 않습니다.
a.length  // => 3: 하지만 배열 길이는 바뀌지 않습니다.
```

### **4.13.5 await** 연산자

await는 비동기 연산을 나타내는 프라미스 객체를 피연산자로 예상하고, 프로그램이 마치 그 비동기 연산이 끝나길 기다리는 것처럼 동작

하지만 실제로 기다리지는 않고 넘어가며 다른 비동기 동작도 동시에 일어 날 수 있다

await 연산자의 값은 프라미스 객체가 어떻게 이행됐는지 나타내는 값

중요한 것은 await는 오직 async 키워드로 선언된 비동기 함수 안에서만 동작한다는 사실

자세한 내용은 13장에서

### **4.13.6 void** 연산자

void는 단항 연산자이며 피연산자 타입을 가리지 않는다

void는 피연산자를 평가한 후 그 값을 버리고 undefined를 반환

```jsx
let counter = 0;
const increment = () => void counter++; 
increment() // => undefined
counter // => 1
```

### **4.13.7** 콤마 연산자 (,)

2항 연산자이며 피연산자의 타입을 가리지 않는다

왼쪽 피연산자를 평가하고, 오른쪽 피연산자를 평가한 후 오른쪽 피연산자의 값을 반환

```jsx
i=0, j=l, k=2; // => 2
i = 0; j = 1; k = 2;
```

왼쪽 표현식을 항상 평가하기는 하지만 그 값은 버 리므로, 콤마 연산자를 사용하는 의미가 있으려면 왼쪽 표현식에 부수 효과가 있어야 한다

```jsx
// 첫 번째 콤마는 let 문의 일부입니다.
// 두 번째 콤마는 콤마 연산자입니다. 이 연산자를 써서
// 표현식 하나를 예상하는 문(for 루프)에 표현식 두 개(i++과 j--)를 넣을 수 있습니다.
for(let i=0,j=10; i < j; i++,j--) { 
	console.log(i+j);
}
```

## **4.14** 요약

- 표현식은 자바스크립트 프로그램의 구절(phrase)과 같습니다
- 표현식은 모두 자바스크립트 값으로 평가될 수 있습니다.
- 표현식에는 값으로 평가되는 것 외에도 변수 할당 같은 부수효과가 있을 수 있습니다
- 리터럴, 변수참조, 프로퍼티 접근 같은 단순한 표현식을 연산자로 묶어서 더 큰 표현식으로 만들 수 있습니다.
- 자바스크립트 연산자는 크게 산술 연산, 비교, 불, 논리, 할당, 비트 조작 연산자로 나눌 수 있으며, 이외에도 조건 연산자를 비롯해 기타 연산자가 더 있습니다.
- 자바스크립트의 +연산자는 숫자를 더할 때나 문자열을 병합할 때 사용할 수 있습니다.
- 논리 연산자 &&와 || 에는 때에 따라 피연산자 중 하나만 평가하는 특별한 ‘단축평가’ 방식이 있습니다.

위 표현식 w를 첫 번째 평가하고, 그 다음 x, y, 그를 순서대로 평가합니다.
그런 다음 y와 그의 값을 곱하고, x의 값을 더한 다음 표현식 W에서 지정한 변수나 프 로퍼티에 할당
