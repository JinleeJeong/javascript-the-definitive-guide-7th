# 4장. 표현식과 연산자

표현식이란 어떤 값으로 평가(evaluate)되는 구절

단순한 표현식을 조합해 복잡한 표현식을 만들 때 연산자 사용

연산자는 피연산자(보통 두 개)의 값을 어떤 형태로 조합해 새 값으로 평가한다

값으로 ‘평가’된다 대신 연산자가 값을 ‘반환’한다고 단순화해서 표현할 때도 있다

## 4.1 기본표현식

가장 단순한 표현식을 기본 표현식

- 리터럴은 문자 그대로 쓰는 값

```jsx
1.23 // 숫자 리터럴
"hello" // 문자열 리터럴
/pattern/ // 정규 표현식 리터럴
```

- 예약어

```jsx
true; // 불 true로 평가됩니다.
false; // 불 false로 평가됩니다.
null; // null로 평가됩니다.
this; // '현재, 객체로 평가됩니다.
```

메서드 바디에서 this는 해당 메서드를 호출한 객체로 평가

- 변수, 상수, 전역 객체의 프로퍼티에 대한 참조 형태

```jsx
i; // 변수 i의 값으로 평가됩니다.
sum; // 변수 sum의 값으로 평가됩니다.
undefined; // 전역 객체의 "undefined" 프로퍼티 값
```

자바스크립트는 프로그램에 있는 식별자를 변수, 상수, 또는 전역 객체의 프로퍼티 라고 가정하고 그 값을 찾는다

그런 이름의 변수가 존재하지 않는다면 존재하지 않는 변수를 평가하려는 시도이므로 ReferenceError가 일어난다

## **4.2** 객체와 배열 초기화 표현식

객체와 배열의 초기화 표현식(initializer)은 그 값이 새로 생성된 객체나 배열인 표현식

이런 초기화 표현식을 객체 리터럴이나 배열 리터럴이라고 부르기도 함

리터럴과 달리 초기화 표현식은 프로퍼티와 요소 값을 지정하는 다양한 하위 표현식으로 구성되므로 기본 표현식은 아니다

**배열 초기화 표현식**

대괄호 안에 콤마로 구분된 리스트를 쓰는 형태의 표현식

배열 초기화 표현식의 값은 새로 생성된 배열

새 배열의 요소는 콤마로 구분된 표현식들의 값으로 초기화된다

배열 초기화 표현식 내부의 요소 표현식 역시 배열 초기화 표현식이 될 수 있다

배열 리터럴에서 콤마 사이 의 값을 생 략하면 정 의 되지 않은 요소가 그 자리에 들어간다

```jsx
let sparseArray = [1,,,,5];
```

마지막에 콤마 있으면 정의되지 않은 요소가 만들어지지는 않음

마지막 표현식 다음의 인덱스에 접근하면 undefined

**객체 초기화 표현식**

대괄호 대신 중괄호 사용

각 하위 표현식은 프로퍼티 이름과 콜론(:) 으로 시작

```jsx
letp={x:2.3,y:-1.2}; //프로퍼티가두개있는객체
let q = {}; // 프로퍼티가 없는 빈 객체
q.x = 2.3; q.y = -1.2; // 이제 q의 프로퍼티는 p의 프로퍼티와 같습니다.

// 중첩도 가능
let rectangle = {
	upperLeft: { x: 2, y: 2 }, 
	lowerRight: { x: 4, y: 5 }
};
```

## **4.3** 함수 정의 표현식

함수 정의 표현식은 함수를 정의하며 그 값은 함수다

함수 정의 표현식을 ‘함수 리터럴’이라고 부른다

```jsx
// 이 함수는 전달받은 값의 제곱을 반환합니다.
let square = function(x) { return x * x; };
```

## **4.4** 프로퍼티 접근 표현식

프로퍼티 접근 표현식은 객체 프로퍼티나 배열 요소의 값으로 평가된다

```jsx
expression.identifier
expression[expression]
```

.이나 [ 앞에 있는 표현식을 첫 번째 로 평가한다

그 값이 null이나 undefined이면 TypeError를 일으킨다

.식별자 문법이 더 간결하긴 하지만, 접근하고자 하는 이름이 유효한 식별자이고 그 이름을 알고 있을 때만 사용할 수 있다

프로퍼티 이름에 스페이스나 구두 점이 들어 있거나, 숫자인 경우(배열), 프로퍼티 이름이 고정되어 있지 않고 계산 결과일 때에는 반드시 대괄호 표기법 사용

### **4.4.1** 조건부 프로퍼티 접근

옵션 체인

a?.b

a가 null이거나 undefined라면 이 표현식은 프로퍼티 b에 접근하려는 시도 없이 undefined로 평가된다

a가 다른 값이라면 a?.b는 a.b처럼 평가된다 (a에 b프로퍼티가 없으면 undefined로 평가)

```jsx
let a = { b: null };
a.b?.c.d // => undefined
```

a는 객체이므로 a.b는 유효한 프로퍼티 접근 표현식

a.b의 값은 null이므로 a.b.c는 TypeError

a.b?.c는 undefined로 평가됨

(a.b?.c).d는 TypeError를 일으킴

a.b?.c.d(괄호 없는 형태)는 undefined로 평가됨

?•의 왼쪽에 있는 하위 표현식이 null이나 undefined로 평가되면 더는 프로퍼티에 접근하려 시도하지 않고 전체표현식을 즉시 undefined로 평가함

[] 대신 ?.[]를 사용하는 조건부 프로퍼티 접근도 있다. a?.[b][c]

```jsx
let a; // 변수 초기화를 깜빡했습니다. 
let index = 0;
try {
	a[index++]; // TypeError가 일어납니다. 
} catch(e) {
	index // => 1: index는 TypeError가 일어나기 전에 증가했습니다. 
}
a?.[index++] // => undefined: a가 정의되지 않았습니다.
index // => 1: ?. []는 단축 평가이므로 index는 증가하지 않았습니다.
a[index++] // TypeError. 정의되지 않은 것에서 인덱스를 찾을 수 없습니다.
```

### 4.5 호출 표현식

호출 표현식은 함수나 메서드를 호출(실행)하는 문법

```jsx
f(0) // f는 함수 표현식이고 0은 인자 표현식입니다. 
Math.max(x,y,z) // Math.max는 함수이고 x, y, z는 인자입니다. 
a.sort() // a.sort는 함수이고 인자는 없습니다.
```

호출 표현식 맨 앞에 있는 표현식이 프로퍼티 접근 표현식 이라면 메서드 호출

### **4.5.1** 조건부호출

조건부 프로퍼티 접근과 마찬가지

before

```jsx
function square(x, log) { // 두 번째 인자는 선택 사항인 함수입니다.
	if (log) { // 선택 사항인 함수 인자를 받았습니다.
		log(x); // 호출합니다.
	}
	return x * x; // 인자의 제곱을 반환합니다.
} 
```

after

```jsx
function square(x, log) { // 두 번째 인자는 선택 사항인 함수입니다. 
	log?.(x); // 함수를 받았으면 호출합니다.
	return x * x; // 인자의 제곱을 반환합니다.
}
```

?.()는 왼쪽에 있는 것이 null이나 undefined인지만 체크한다

```jsx
o.m() // 일반적인 프로퍼티 접근, 일반적인 호출 
o?.m() // 조건부 프로퍼티 접근, 일반적인 호출 
o.m?.() // 일반적인 프로퍼티 접근, 조건부 호출
```

첫 번째 표현식에서 o는 반드시 객체여야 하고, m 프로퍼티가 있어야 하며, 그 프로퍼티의 값도 반드시 함수여야 합니다. 

두 번째 표현식에서 o가 null이나 undefined 라면 전체 표현식은 undefined로 평가됩니다. o가 null이나 undefined가 아니라면 반드시 m프로퍼티가 있어야 하고 그 값은 반드시 함수여야 합니다. 

세 번째 표현식에서 o는 반드시 null이나 undefined가 아니어야 합니다. o에 m 프로퍼티가 없거나 그 프로퍼티 값이 null이라면 전체 표현식이 undefined로 평가됩니다.

### **4.6** 객체 생성 표현식

객체 생성 표현식은 객체를 생성하고 함수(생성자)를 호출해 객체 프로퍼티를 초기화한다

객체 생성 표현식은 호출 표현식과 같지만, 그 앞에 new 키워드를 붙인다는 점이 다르다

```jsx
new Object()
new Point(2,3)

// 생성자 함수에 전달할 인자가 없다면 빈 괄호 생략 가능
new Object 
new Date
```

객체 생성 표현식의 값은 새로 생성된 객체

### **4.7** 연산자 개요

**4.7.1** 피연산자개수

**4.7.2** 피연산자와 결과 타입

**4.7.3** 연산자와 부수 효과

**4.7.4** 연산자 우선순위

**4.7.5** 연산자 결합성

**4.7.6** 평가 순서

