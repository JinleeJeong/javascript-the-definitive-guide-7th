# 4장 표현식과 연산자

- 표현식이란 어떤 값으로 평가되는 구절
- 복잡한 표현

## 1. 기본 표현식

- 가장 단순한 표현식
- 상수, 리터럴 값, 일부 키워드, 변수 참조

```tsx
// 리터럴 
'hello'

// 예약어
true
null
this

// 변수 참조
i // 변수 i의 값으로 평가 
undefined // 전역 객체의 undefined 프로퍼티 값
```

---

## 2. 객체와 배열 초기화 표현식(객체 리터럴)

- 그 값이 새로 생성된 객체나 배열인 표현식
→ 객체 리터럴이나 변수 리터럴이라고 부르기도 함
- 초기화 표현식은 프로퍼티와 요소 값을 지정하는 다양한 하위 표현식으로 구성되므로 → 기본 표현식이 아님

```tsx
[]
[1,2,3]

{}
{x: 'hello'}
```

---

## 4. 프로퍼티 접근 표현식

- 프로퍼티 접근 표현식은 객체 프로퍼티나 배열 요소의 값으로 평가
- 2가지로 접근  가능
    - exp.id
    - exp[ id ]
- `.`, `[` 앞에 있는 표현식을 첫 번째로 평가
→ 이 값이 null, undefined이면 이 둘은 프로퍼티를 가질 수 없는 값 
→ TypeError
- `.` 식별자 문법이 간단하지만 이름에 스페이스나, 구두점이 들어가거나, 숫자인 경우에는 사용하기 힘들다 → 대괄호 식별자 문법을 사용

### 4.1. 조건부 프로퍼티 접근

- ES2020에 새롭게 추가된 접근 표현식
- JS에서 프로퍼티를 가질 수 없는 값은 null, undefined뿐 
→ 접근 표현식 왼쪽에 있는 것이 null, undefined로 평가되면 TypeError
→ 조건부 프로퍼티를 이용해 이러한 문제를 해결 가능

```tsx
a?.b.c.d
```

- a가 null이거나 undefined라면 b에 접근하려는 시도 없이 undefined로 평가
→ TypeError를 발생하지 않음
- 단축 평가를 통해 접근 시도하지 않고 → 전체 표현식을 즉시 undefined로 평가

---

## 5. 호출 표현식

- 메서드를 호출(실행)하는 문법

```tsx
f(0)
Math.max(x, y, z)
a.sort()
```

- 첫 번째로 함수 표현식을 평가하고
→ 함수 인자 표현식을 평가해 인자 값 리스트를 만든다
- retrun 문을 사용해 반환하면 → 그 값이 호출 표현식의 값
- 호출 표현식 맨 앞에 있는 표현식이 프로퍼티 접근 표현식이라면
→ 이 호출은 메서드 호출

### 5.1 조건부 호출

```tsx
o.m()
o?.m()
o.m?.()
```

- ES2020에서는 조건부 호출 가능
`()` 대신 `?.()` 가능
- `?.` 왼쪽에 있는 표현식이 null이나 undefined 일 때 호출 표현식 전체를 undefined로 가
→ 하지만 실제로 함수인지는 체크하지 않는다.

---

## 6. 객체 생성 표현식

- 호출 표현식과 같지만 앞에 new 키워드를 붙인다.
→ `new Object()`
- 생성자 함수에 전달 할 인자가 없다면 빈 괄호 생략 가능
→ `new Object`

---

## 7. 연산자 개요

- 연산자는 산술 표현식, 비교 표현식, 논리 표현식, 할당 표현식 등에 사용
- delete, instanceof와 같이 키워드 연산자도 있음

### 7.2 피연산자와 결과 타입

- 값의 타입에 관계없이 동작하는 연산자도 있지만
→ 대부분 피연산자가 특정 타입 일 것으로 간주하고
→ 특정 타입의 값을 반환
- JS는 연산에 따라 피연산자의 타입을 3.9절에서 한 것과 같은 방식으로 변환

### 7.3 연산자의 부수 효과

- 일부 표현식에는 이후의 평가 결과가 영향을 미치는 
→ 사이드 이펙트가 있다
- `=`, `++`, `—` , `delete`(할당, 증가, 감소 연산자)
- 다른 연산자에는 부수 효과가 없다

### 7.4 연산자 우선순위

- 연산자 우선 순위는 동작 순서를 결정한다.
- 우선순위가 높은 연사자는 낮은 연산자 보다 먼저 실행된다.
→ `w = x + y*z`
→ 곱셈이 먼저 이뤄지고 할당이 낮으므로 가장 마지막에 이뤄진다

- 이러한 우선순위를 괄호를 이용해서 높게 줄 수 있다
- 연산자 우선순위가 불확실하다고하면 괄호를 사용해서 명시적으로 정해줄 수 있음

- 할당은 우선순위가 아주 낮으므로 거의 마지막에 수행

### 7.5 연산자 결합성

- 오른쪽에서 왼쪽으로 수행(우결합성): 지수, 단항, 할당, 조건

### 7.6 평가순서

- 연산자 우선순위와 연관성은 복잡한 표현식에서 어떤 순서로 동작이 수행되는지는 지정
- 그러나 하위 표현식이 평가되는 순서는 지정하지 않음

`w = x + y * z`

- x, y, z를 순서대로 평가
- JS는 항상 표현식을 외쪽에서 오른쪽으로 평가
- 평가 순서는 평가하는 표현식에 다른 표현식의 값에 영향을 미치는 부수 효과가 있을 때에만 의미가 있다.

---

## 8. 산술 표현식

- **, *, /, %, +, -
- 산술 연산자는 BigInt와 일반적인 숫자에 똑같이 사용 가능
- 피연산자의 타입만 섞지 않으면 된다
- 피연산자를 평가해서 필요하다면 숫자로 변환하고 → 계산
- 숫자가 아니고, 숫자로 변환도 될 수 없다면 → NaN
- **는 오른쪽에서 왼쪽으로 동작

### 8.1 + 연산자

- 문자열 병합, 산술 연산
- + 연산자의 변환 규칙은 문자열 병합에 우선 순위가 있다
- 두 피연산자 모두 문자열로 판단 할 수 없을 때 덧셈 수행
- 결합성은 왼쪽에서 오른쪽

- 하나가 객체라면 → 기본 값으로 변환
- 기본 값으로 변환 후 하나가 문자열이면 → 문자열로 변환시켜 병합
- 둘 다 문자열이 아니라면 숫자로 변환 후 더함

### 8.2. `++`, `—` 전위, 후위 연산자

```tsx
let i = 1, j = ++i // 모두 2
let n  = 1, m = n++; // n은 2, m은 1 
```

`++Num` : 전위 증가 연산자 

- 피연산자에 1을 더하고, 그 값으로 평가

`Num++` : 후위 증가 연산자 

- 1을 더하긴 하지만 더하기 전의 값으로 평가

---

## 9.  관계 표현식

- 두 값의 관계로 항상 불 값으로 평가
- `===` 는 타입 변환은 수행하지 않고, 
`==` 는 타입 변환을 수행한다.

### 9.2 비교 연산자

- 숫자와 문자열에 대해서만 가능하므로 숫자나 문자열로 변환
- 피연산자는 숫자나 문자열로 변환

- 객체면 기본 값으로 변환하고
- 모두 문자열이라면 문자열 순서 비교
- 문자열이 아닌 것이 있다면 숫자로 변환해 비교

- 아스키 대문자는 모두 소문자보다 작음
→ String.localeCompare(), String.toLowerCase 등을 사용해 비교하는 것이 좋음

### 9.3 in연산자

- in 왼쪽에는 문자열, 심벌, 문자열로 변환 될 수 있는 값
- 오른쪽에는 객체를 예상한다

### instanceof

- 왼쪽에 객체, 오른쪽은 객체의 클래스라고 예상
- 왼쪽에 있는 객체가 오른쪽에 있는 클래스의 인스턴스라면 true, 
아니면 false

---

### 4.10 논리 표현식

### `&&`

1. AND
2. 단축 평가 
→ 왼쪽에 있는 값이 false면 이후를 평가하지 않는다.
3. 두 관계 표현식을 연결하는 용도

### `||`

1. 단축 평가
→ 첫 값이 true면 더 이상 평가를 진행하지 않음

### `!`

```tsx
!(p && q) === (!p || !q) // 드모르간
```

- &&, || 와는 달리 피연산자를 불 값으로 변환한 다음 부정
- 따라서 항상 true, false 반환
- 가독성을 해치는 경우가 많은데 → 드모르간 법칙을 이용해 풀어주는 것도 좋음

---

### 11. 할당 표현식

- = 연산자를 사용해 할당
- 때때로 할당 표현식의 값을 더 큰 표현식의 일부분으로 사용하는 경우가 있음
- 예를들어 다음과 같이 표현식 하나에서 값을 할당하는 동시에 테스트 할 수 있다

```tsx
(a = b) === 0
```

- =의 우선순위는 매우 낮다
- 결합성은 오른쪽에서 왼쪽

---

## 12. eval

- 문자열을 전달 받으면 
→ JS 코드로 분석 할 수 없는지 시도하고, 실패하면 SyntaxError
- eval은 자신이 호출한 코드의 변수 환경을 사용
- 문자열을 성공적으로 분석하면 평가하고, 해당 문자열의 마지막 표현식 또는 문의 값을 반환하고,
마지막 표현식이나 문에 값이 없으면 undefined를 리턴

### 12.2 전역 eval

- 로컬 변수를 엉망으로 만들어서

---

## 13. 기타 연산자

### ?:

```tsx
x > 0 ? '크다' : '작다'
```

### null 병합 연산자(??)

- 정의된 첫번째 피연산자로 평가
- 왼쪽 피연산자가 null, undefined가 아닐마ㅕㄴ 그 값을 반환
- 아니면 오른쪽 값 반환
- && 와 마찬가지로 역시 단축 평가

### typeof

- 피연산자 타입을 나타냄
- 함수, 배열도 객체로 평가
→ 객체와 기본 타입을 구별하는 용도로 밖에 사용 할 수 없는 한계

### await

- 비동기 연산을 나타내는 프라미스 객체를 피연산자로 예상하고,
마치 그 비동기 연산이 끝나길 기다리는 것 처럼 동작
- 실제로는 기다리지 않고 넘어가며 다른 비동기 동작도 동시에 일어 날 수 있다
- 이 값은 프라미스 객체가 어떻게 이행됐는지 나타내는 값

### void

- 단항 연산자
- 피연산자 타입을 가리지 않음
- 피연산자를 평가한 이후 값을 버리고 →  undefined를 반환

### ,연산자

- 피연산자의 타입을 가리지 않음
- 피연산자를 평가하고, 오른쪽 피연산자를 평가한 후 오른쪽 피연산자의 값을 반환

```tsx
i = 0, j = 1, k = 2;

i = 0; j = 1; k = 2;
```

- 왼쪽 표현식을 항상 평가하지만 값은 버림
→ 의미가 있으려면 왼쪽 표현식에 사이드 이펙트가 있어야함

```tsx
for (let i=0, j=10; i < j; i++, j--){}
```
