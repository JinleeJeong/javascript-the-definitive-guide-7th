# 8장 함수

## 🍂 8.1 함수 정의

> **`function`**
>
> 함수를 정의하는 가장 단순한 방법이다. 선언으로도, 표현식으로도 사용할 수 있다.

> **화살표 함수**
>
> ES6에서 `function` 키워드 없이 함수를 정의하는 새로운 방법이다.

- 함수를 다른 함수에 인자로 전달할 때 유용하다.

### 8.1.1 함수 선언

함수 선언은 `function` 키워드 뒤에 다음 세 가지 구성 요소를 사용한다.

1. **함수 이름이 될 식별자**

   - 이름은 함수 선언에서 뺼 수 없는 부분이다. 이 이름은 변수 이름으로 쓰이며, 새로 정의된 함수 객체가 이 변수에 할당된다.

2. **괄호로 감싸고 콤마로 구분한 0개 이상의 식별자 리스트**

   - 이 식별자들은 함수 매개변수 이름이며 함수 바디 안에서 로컬 변수로 동작한다.

3. **중괄호로 감싼 0개 이상의 자바스크립트 문**

   - 이 문이 함수 바디이며 함수를 호출할 때마다 실행된다.

함수 선언문은 자신을 포함하는 스크립트, 함수, 또는 블록 맨 위로 끌어올려지므로 함수 선언문으로 정의한 함수는 정의하기 전에도 호출할 수 있다. 블록 안에서 선언된 함수는 모두 그 블록 전체에 존재하며, 자바스크립트 인터프리터가 해당 블록의 코드를 실행하기 전에 정의된다고 봐도 된다.

**`return`**

`return` 문은 함수 실행을 멈추고 바로 다음에 있는 표현식의 값을 호출자에게 반환한다. 함수에 `return` 문이 없으면 함수는 함수 바디의 문을 끝까지 실행하고 호출자에게 `undefined`를 반환한다.

### 8.1.2 함수 표현식

> **함수 표현식**
>
> 함수 선언과 거의 비슷하지만, 더 큰 표현식이나 문의 일부로서 존재하고 이름을 붙이지 않아도 된다는 점이 다르다.

```js
const square = function (x) {
  return x * x;
};
```

- 이 함수 표현식은 인자의 제곱을 계산하는 함수를 정의한다.
- 함수를 변수에 할당했다.

```js
const f = function fact(x) {
  if (x <= 1) return 1;
  else return x * fact(x - l);
};
```

- 함수 표현식에도 이름을 쓸 수 있으며 재귀 호출에 유용하다.

```js
[3, 2, 1].sort(function (a, b) {
  return a - b;
});
```

- 함수 표현식을 다른 함수의 인자로 사용할 수도 있다.

```js
let tensquared = (function (x) {
  return x * x;
})(10);
```

- 함수 표현식을 정의하는 즉시 호출할 때도 있다.

표현식으로 정의한 함수에 이름을 붙이는 것은 선택 사항이다. 함수 표현식을 쓸 때는 실수로 함수를 덮어 쓰지 않도록 `const` 를 사용하는 것이 좋은 습관이다. 함수는 이름으로 자기 자신을 참조할 수 있다. 함수 표현식에 이름이 있으면, 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조한다. 즉, 함수 이름은 함수 안에서 로컬 변수가 된다. 표현식으로 정의한 함수는 대부분 이름이 필요 없으므로 정의가 더 간결하다.

| 함수 선언                                                                                                    | 함수 표현식                                                                                                                                                                                      |
| ------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 함수 선언은 실제로 변수를 선언하며 그 변수에 함수 객체를 할당한다.                                           | 함수 표현식은 변수를 선언하지 않는다.                                                                                                                                                            |
| 선언 형태를 사용하면 함수 객체는 자신을 포함하는 코드가 실행되기 전에 존재하며 정의하기 전에 호출할 수 있다. | 함수를 정의하는 표현식이 실제로 평가되기 전에는 함수가 존재하지 않는다. 함수를 호출하려면 반드시 함수를 참조할 수 있어야 하는데, 표현식으로 정의된 함수는 변수에 할당되기 전에는 참조할 수 없다. |

### 8.1.3 화살표 함수

화살표 함수는 문이 아니라 표현식이므로 `function` 키워드는 사용하지 않으며 함수 이름도 필요 없다. 화살표 함수의 일반적인 형태는 괄호 안에 콤마로 구분한 매개변수 리스트를 쓰고, 그 뒤에 => 화살표와 중괄호로 감싼 함수 바디를 쓰는 형태이다.

```js
const sum = (x, y) => {
  return x + y;
};
```

화살표 함수를 작성할 때 함수 매개변수와 => 사이에서 줄바꿈을 해선 안 된다. 줄바꿈을 하면 `const polynomial = x`처럼 문법적으로 유효한 할당문이 만들어진다.

**객체 리터럴 반환**

화살표 함수의 바디가 `return` 문 하나라고 해도, 반환할 표현식이 객체 리터럴이라면 객체 리터럴을 명시적으로 괄호 안에 써서 함수 바디의 중괄호와 객체 리터럴의 중괄호를 혼동하지 않게 해야 한다.

```js
const f = x => { return { value: x }; }; // 좋음: f()는 객체를 반환합니다.
const g = x => ({ value: x }); // 좋음: g()는 객체를 반환합니다.
const h = x => { value: x }; // 나쁨: h()는 아무것도 반환하지 않습니다.
const i = x => { v: x, w: x }; // 나쁨: 문법 에러
```

**배열 메서드 사용**

`map()`, `filter()`, 같은 배열 메서드를 사용할 때 화살표 함수 형태를 자주 사용한다.

```js
// null 요소를 제거한 배열 사본을 만듭니다.
let filtered = [1, null, 2, 3].filter(x => x !== null); // filtered == [1, 2, 3]
// 숫자의 제곱을 구합니다.
let squares = [1, 2, 3, 4].map(x => x * x); // squares == [1, 4, 9, 16]
```

## 🍂 8.2 함수 호출

함수는 다섯 가지 방법으로 호출할 수 있다.

1. 함수로 호출

2. 메서드로 호출

3. 생성자로 호출

4. `call()`, `apply()` 메서드를 통해 간접적으로 호출

5. 자바스크립트 언어 기능을 통한 묵시적 호출

### 8.2.1 함수로 호출

함수 표현식이 프로퍼티 접근 표현식이라면, 즉 해당 함수가 객체 프로퍼티거나 배열 요소라면, 표현식은 메서드 호출 표현식이다.

```js
printprops({ x: 1 });
let total = distance(0, 0, 2, 1) + distanced(2, 1, 3, 5);
let probability = factorial(5) / factorial(13);
```

괄호 안에 들어 있는 각 인자 표현식을 호출 시점에서 평가한 값이 인자가 된다. 함수 바디에서는 각 매개변수가 이에 대응하는 인자로 평가된다.

**`this`**

일반 모드에서 함수의 호출 컨텍스트(this)는 전역 객체이다. 스트릭트 모드의 호출 컨텍스트는 `undefined` 이다. 단, 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 `this` 값을 상속한다. 메서드가 아니라 함수로 호출되도록 설계된 함수는 일반적으로 `this` 키워드를 전혀 사용하지 않는다. 하지만 `this` 키워드를 사용해서 스트릭트 모드에 있는지 확인하는 것은 가능하다.

- 스트릭트 모드에 있는지 판단하는 함수

```js
const strict = (function () {
  return !this;
})();
```

### 8.2.2 메서드로 호출

메서드 호출의 인자와 반환 값은 일반적인 함수 호출과 똑같다. 하지만 메서드 호출과 함수 호출은 호출 컨텍스트가 다르다는 중요한 차이가 있다.

```js
let calculator = { // 객체 리터럴
	operand1: 1,
	operand2: 1,
	add() { // 메서드 단축 문법을 썼습니다.
		// this 키워드는 포함하는 객체를 참조합니다.
		this.result = this.operandl + this.operand2;
	}
}；
calculator.add(); // 메서드 호출을 통해 1 + 1을 계산합니다.
calculator.result // => 2
```

메서드 호출은 대괄호 표현식으로도 메서드를 호출할 수 있다.

```js
o['m'](x, y); // o.m(x, y)와 동등합니다.
a[0](z); // a[0]이 함수라면 역시 메서드 호출입니다.
customer.surname.toUpperCase(); // customer.surname의 메서드를 호출합니다.
f().m(); // f()의 반환 값의 메서드인 m()을 호출합니다.
```

**`this`**

메서드와 `this` 키워드는 객체 지향 프로그래밍 패러다임의 핵심이다. 메서드로 사용되는 함수는 모두 자신을 호출하는 객체를 묵시적인 인자로 받는다. 메서드는 일반적으로 그 객체에서 동작하며, 메서드 호출 문법은 함수가 객체에서 동작한다는 의미를 명쾌하게 전달한다.

```js
rect.setSize(width, height);
setRectSize(rect, width, height);
```

`this` 키워드는 변수의 스코프 규칙을 따르지 않는다. 화살표 함수의 예외를 제외하면 중첩된 함수는 포함하는 함수의 `this` 값을 상속하지 않는다. 중첩된 함수를 메서드로 호출하면 그 `this` 값은 호출한 객체이다. 중첩된 함수를 함수로 호출하면 그 `this` 값은 일반 모드에서는 전역 객체이고, 스트릭트 모드에서는 `undefined` 이다. 메서드 안에 정의된 함수를 함수로 호출하면 this를 통해 메서드의 호출 컨텍스트를 참조할 수 있다고 생각하기도 하는데, 이는 흔히 저지르는 실수이다.

```jsx
let o = {
  // 객체 o
  m: function () {
    // 객체의 메서드 m
    let self = this; // this 값을 변수에 저장합니다.
    this === o; // => true: this는 객체 o입니다.
    f(); // 보조 함수 f()를 호출합니다.

    function f() {
      // 중첩된 함수 f
      this === o; // => false: this는 전역 객체이거나 undefined입니다.
      self === o; // => true: self는 외부 this 값입니다.
    }
  },
};
o.m(); // 객체 o에서 메서드 m을 호출합니다.
```

중첩된 함수 `f()` 에서 `this` 키워드는 객체 `o` 와 같지 않다. 자바스크립트 언어의 결함으로 지적받는 부분이고, 반드시 인지하고 있어야 한다. 위 코드는 널리 쓰이는 우회 방법을 제시한다. 메서드 `m` 안에서 `this` 값을 변수 `self` 에 할당하면, 중첩된 함수 `f` 안에서 포함하는 객체를 `this` 대신 `self` 로 참조할 수 있다.

**`this` 상속**

ES6 이후에는 중첩된 함수 `f` 를 화살표 함수로 변환해 `this` 값을 상속하게 하는 방법도 가능하다.

```jsx
const f = () => {
  this === o; // true: 화살표 함수는 항상 this를 상속합니다.
};
```

표현식으로 정의된 함수는 끌어올려지지 않으므로 이 코드가 동작하기 위해서는 메서드 `m` 안에서 `f`를 정의하는 부분을 호출 이전으로 옮겨야 한다.

### 8.2.3 생성자로 호출

생성자를 호출하면 생성자의 `prototype` 프로퍼티에서 지정된 객체를 상속하는 빈 객체를 새로 생성한다. 생성자 함수는 객체를 초기화할 의도로 만들어졌으며, 이렇게 새로 생성된 객체가 호출 컨텍스트로 사용되므로 생성자 함수는 새 객체를 `this` 키워드로 참조할 수 있다.

**`return`**

생성자 함수는 일반적으로 `return` 키워드를 사용하지 않는다. 생성자 함수는 일반적으로 새 객체를 초기화하여 함수 바디의 끝에 도달하면 종료한다. 이 경우 새 객체가 생성자 호출 표현식의 값이다. 생성자가 명시적으로 `return` 문을 사용해 객체를 반환하면 그 객체가 호출 표현식의 값이 된다. 생성자가 `return` 문을 값 없이 사용하거나 기본 값을 반환한다면 반환 값을 무시하고 새 객체를 호출 표현식의 값으로 사용한다.

### 8.2.4 간접적 호출

`call()`과 `apply()`는 함수를 간접적으로 호출한다. 두 메서드 모두 호출 시점에 `this` 값을 직접 명시할 수 있으므로, 함수를 어떤 객체의 메서드로도 호출할 수 있다.

### 8.2.5 묵시적 함수 호출

묵시적으로 호출한 함수에서 버그, 부작용, 성능 문제가 발생한다면, 단순히 코드를 들여다보는 것으로는 언제 호출되는지 명확히 알기 어려우므로 일반적인 함수에 비해 해결하기가 훨씬 어렵다.

1. 객체에 게터나 세터가 있다면 프로퍼티 값에 접근할 때 이 메서드가 호출될 수 있다.

2. 문자열을 받는 컨텍스트에 객체를 사용하면 `toString()` 메서드가 호출된다. 마찬가지로, 객체를 숫자 컨텍스트에 사용하면 `valueOf()` 메서드가 호출된다.

3. 이터러블 객체의 요소를 순회할 때 여러가지 메서드가 호출될 수 있다.

4. 태그된 템플릿 리터럴도 함수 호출을 일으킬 수 있다.

5. 프록시 객체는 완전히 함수에 의해 제어된다. 이런 객체에는 어떤 동작을 취하든 항상 함수가 호줄된다.

## 🍂 8.3 함수 매개변수

## 🍂 8.4 값인 함수

## 🍂 8.5 네임스페이스인 함수

## 🍂 8.6 클로저

## 🍂 8.7 함수 프로퍼티, 메서드, 생성자

## 🍂 8.8 함수형 프로그래밍

## 🍂 8.9 요약

- `function` 키워드나 ES6의 화살표 문법으로 함수를 정의할 수 있습니다.

- 함수는 메서드나 생성자로도 사용할 수 있습니다.

- ES6 기능 중에는 선택 사항인 함수 매개변수에 기본 값을 할당하는 기능, 나머지 매개변수를 사용해 인자 여럿을 배열에 모으는 기능, 객체와 배열을 분해해 함수 매개변수로 사용하는 기능 등이 있습니다.

- 분해 연산자 `...` 를 사용해 배열이나 이터러블 객체의 요소를 함수 인자로 전달해 호출할 수 있습니다.

- 외부 함수 안에서 정의되고 반환된 함수는 외부 함수의 어휘적 스코프에 대한 접근을 유지하고 있으므로, 외부 함수에서 정의한 변수에 접근할 수 있습니다. 이런 함수를 클로저라 부르며, 클로저는 충분히 알아 둘 만한 기법입니다.

- 함수는 자바스크립트에서 조작할 수 있는 객체이며, 이를 통해 함수형 프로그래밍 스타일을 사용할 수 있습니다.
