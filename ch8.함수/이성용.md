# 8장 함수

함수는 자바스크립트 프로그램의 기본적인 구성 요소이며 대부분의 프로그래밍 언어에 있는 공통 기능이다. 서브루틴이나 프로시저라는 이름으로 함수의 개념에 이미 익숙한 사람도 있을 것이다.

함수는 한 번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록이다.

자바스크립트 함수는 매개변수화(parameterized) 된다.

함수 정의에는 매개 변수(parameter)라고 불리는 식별자 리스트가 있는데, 이들은 함수 바디에서 로컬 변수처럼 동작한다.

함수를 호출할 때는 매개변수에 값을 전달하는데 이를 인자 (argument)라고 한다. 함수는 보통 인자를 사용해 반환 값을 도출하며, 이 값이 함수 호출 표현식의 값이 된다.

매개변수 외에도 각 호출에는 호출 컨텍스트가 존재하며 이것이 this 키워드의 값이다.

객체 프로퍼티로 할당된 함수를 객체의 메서드라고 부른다. 객체를 통해 함수를 호출하면 그 객체가 호출컨텍스트, 즉 함수의 this 값이다.

객체를 새로 만들 목적으로 설계한 함수를 생성자라고 부른다.

자바스크립트 함수는 객체이며 프로그램에서 조작할 수 있다. 자바스크립트는 함수를 변수에 할당하거나 다른 함수에 전달할 수 있다. 함수는 객체이므로 프로퍼티를 정의할 수 있고 함수의 메서드를 호출하는 것도 가능하다.

자바스크립트 함수는 다른 함수 안에서 정의할 수 있으며, 이렇게 정의된 함수는 자신이 정의된 스코프의 변수에 접근할 수 있다. 이런 의미에서 자바스크립트 함수는 클로저(closure)이다. 클로저를 통해 중요하고 강력한 프로그래밍 기법을 사용할 수 있다.

## 함수 정의

function

function 키워드는 선언으로도, 표현식으로도 사용할 수 있다.

ES6는 function 키워드 없이 함수를 정의하는 새로운 방법인 화살표 함수를 도입했다.

객체 리터럴과 클래스 정의 메서드를 정의하는 단축 문법이 있다.

Function() 생성자를 사용해 함수를 정의할 수도 있다.

function*으로 정의하는 제너레이터 함수, async function으로 정의하는 비동기 함수도 있다.

### 함수 선언

함수 선언은 function 키워드 뒤에 다음 세 가지 구성 요소를 쓴다.

함수 이름이 될 식별자 이름은 함수 선언에서 뺄 수 없는 부분이다. 이 이름은 변수 이름으로 쓰이며, 새로 정의된 함수 객체가 이 변수에 할당된다.

괄호로 감싸고 콤마로 구분한 0개 이상의 식별자 리스트. 이 식별자들은 함수 매개변수 이름이며 함수 바디 안에서 로컬 변수로 동작한다.

중괄호로 감싼 0개 이상의 자바스크립트 문. 이 문이 함수 바디이며 함수를 호출 할 때마다 실행된다.

```jsx
// 0의 각 프로퍼티 이름과 값을 출력합니다. undefined를 반환합니다.
function printprops(o) {
	for (let p in o) {
		console.log('${p}: ${o[p]}\n');
	}
}

// 카르테시안 좌표 (x1, y1)과 (x2, y2) 사이의 거리를 계산합니다.
function distance(x1, y1, x2, y2) {
	let dx = x2 - x1;
	let dy = y2 - y1;
	return Math.sqrt(dx*dx + dy*dy);
}

// 팩토리얼을 계산하는 재귀 함수(자신을 호출하는 함수)
// x!는 x 이하의 양의 정수를 모두 곱한 값입니다.
function factorial(x) {
	if (x <= 1) return 1;
	return x * factorial(x - 1);
}
```

함수 선언에서 이해해야 할 중요한 점은 함수의 이름이 변수이며 그 값은 함수 자체라는 점이다.

함수 선언문은 자신을 포함하는 스크립트, 함수, 또는 블록 맨 위로 끌어올려지므로 함수 선언문으로 정의한 함수는 정의하기 전에도 호출할 수 있다. 블록 안에서 선언된 함수는 모두 그 블록 전체에 존재하며, 자바스크립트 인터프리터가 해당 블록의 코드를 실행하기 전에 정의된다고 봐도 된다.

ES5 이전에는 자바스크립트 파일이나 다른 함수의 최상위 레벨에서만 함수를 선언할 수 있다. 이 규칙을 우회하는 실행 환경도 존재하긴 했지만, 루프나 조건문, 기타 블록 안에서 함수를 정의하는 것은 엄밀히 말해 규칙을 어기는 것이었다.

ES6 스트릭트 모드에서는 블록 안에서 함수를 선언할 수 있다. 이렇게 블록 안에서 정의된 함수는 해당 블록 안에서만 존재하며 블록 바깥에서는 볼 수 없다.

### 함수 표현식

함수 표현식은 함수 선언과 거의 비슷하지만, 더 큰 표현식이나 문의 일부로서 존재하고 이름을 붙이지 않아도 된다는 점이 다르다.

```jsx
// 이 함수 표현식은 인자의 제곱을 계산하는 함수를 정의합니다.
// 함수를 변수에 할당했습니다.
const square = function(x) { return x*x; };

// 함수 표현식에도 이름을 쓸 수 있으며 재귀 호출에 유용합니다.
const f = function fact(x) {
	if (x <= 1) return 1;
	else return x*fact(x-l);
};

// 함수 표현식을 다른 함수의 인자로 사용할 수도 있습니다.
[3,2,1].sort(function(a,b) { return a-b; });

// 함수 표현식을 정의하는 즉시 호출할 때도 있습니다.
let tensquared = (function(x) {return x*x;}(10));
```

표현식으로 정의한 함수에 이름을 붙이는 것은 선택 사항이며 앞의 예제에서는 대부분 이름을 생략했다.

함수 선언은 실제로 변수를 선언하며 그 변수에 함수 객체를 할당한다. 반면 함수 표현식은 변수를 선언하지 않는다.

새로 정의한 함수 객체를 나중에 다시 참조해야 한다면, 프로그래머의 선택에 따라 변수 또는 상수에 할당한다.

함수 표현식을 쓸 때는 실수로 함수를 덮어 쓰지 않도록 const를 사용하는 것이 좋은 습관이다.

함수 선언으로 함수 f()를 정의하는 것과 표현식으로 함수를 생성하고 변수 f에 할당하는 것 사이에는 중요한 차이가 있다.

선언 형태를 사용하면 함수 객체는 자신을 포함하는 코드가 실행되기 전에 존재하며 정의하기 전에 호출할 수 있다.

표현식으로 정의된 함수는 이렇게 동작하지 않는다. 함수를 정의하는 표현식이 실제로 평가되기 전에는 함수가 존재하지 않는다. 또한 함수를 호출하려면 반드시 함수를 참조할 수 있어야 하는데, 표현식으로 정의된 함수는 변수에 할당하기 전에는 참조할 수 없다. 따라서 표현식으로 정의된 함수는 정의하기 전에 호출할 수 없다.

### 화살표 함수

```jsx
const sum = (x, y) => { return x + y; };
const sum = (x, y) => x + y;
const polynomial = x => x * x + 2* x + 3;
const constantFunc = () => 42;
```

화살표 함수를 작성할 때 함수 매개변수와 => 사이에서 줄바꿈을 해선 안 된다. 만약 줄바꿈을 한다면 const polynomial = x처럼 문법적으로 유효한 할당문이 만들어진다.

```jsx
const f = x => { return { value: x }; }; // 좋음: f()는 객체를 반환합니다.
const g = x => ({ value: x }); // 좋음: g()는 객체를 반환합니다.
const h = x => { value: x }; // 나쁨: h()는 아무것도 반환하지 않습니다.
const i = x => { v: x, w: x }; // 나쁨: 문법 에러
```

또한 화살표 함수의 바디가 return 문 하나라고 해도, 반환할 표현식이 객체 리터럴이라면 객체 리터럴을 명시적으로 괄호 안에 써서 함수 바디의 중괄호와 객체 리터럴의 중괄호를 혼동하지 않게 해야 한다.

```jsx
// null 요소를 제거한 배열 사본을 만듭니다.
let filtered = [1, null, 2 ,3].filter(x => x !== null); // filtered == [1,2,3]
// 숫자의 제곱을 구합니다.
let squares = [1, 2, 3 ,4].map(x => x * x); // squares == [1,4,9,16]
```

### 중첩된 함수

```jsx
function hypotenuse(a, b) {
	function square(x) { return x*x; }
	return Math.sqrt(square(a) + square(b));
}
```

중첩된 함수에서 흥미로운 것은 변수 스코프 규칙이다. 중첩된 함수는 자신을 포함하는 함수(들)의 매개변수와 변수에 접근할 수 있다.

## 함수 호출

### 함수로 호출

```jsx
printprops({x: 1});
let total = distance(0,0,2,1) + distanced,1,3,5);
let probability = factorial(5)/factorial(13);
```

<aside>
💡 조건부 호출

ES2020에서는 함수 표현식과 여는 괄호 사이에 ?.를 넣어서 함수가 null이나 undefined가 아닌 경우에만 호출하게 할 수 있다. 즉, 부수 효과가 없다고 가정하면 표현식 f?. (x)는 다음 코드와 동등하다.

```jsx
(f !== null && f !== undefined) ? f(x) : undefined
```

</aside>

일반 모드에서 함수의 호출 컨텍스트(this)는 전역 객체이다. 스트릭트 모드의 호출 컨텍스트는 undefined이다. 단, 화살표 문법으로 정의한 함수는 항상 자신이 정의된 곳의 this 값을 상속한다.

메서드가 아니라 함수로 호출되도록 설계된 함수는 일반적으로 this 키워드를 전혀 사용하지 않는다. 하지만 this 키워드를 사용해서 스트릭트 모드에 있는지 확인하는 것은 가능하다.

```jsx
// 스트릭트 모드에 있는지 판단하는 함수
const strict = (function() { return !this; }());
```

### 메서드로 호출

```jsx
o.m = f;
o.m();
o.m(x, y);
```

함수 표현식 o.m과 인자 표현식 x, y가 들어 있다. 함수 표현식이 프로퍼티 접근 표현식이므로 이 함수는 일반적인 함수가 아니라 메서드로 호출된다.

메서드 호출의 인자와 반환 값은 일반적인 함수 호출과 똑같다. 하지만 메서드 호출과 함수 호출은 호출 컨텍스트가 다르다는 중요한 차이가 있다. 프로퍼티 접근 표현식은 객체(o)와 프로퍼티 이름(m)으로 이루어진다. 메서드 호출 표현식에서 객체 o는 호출 컨텍스트가 되고 함수 바디는 키워드 this를 통해 그 객체를 참조할 수 있다.

```jsx
let calculator = { // 객체 리터럴
	operand1: 1,
	operand2: 1,
	add() { // 메서드 단축 문법을 썼습니다.
		// this 키워드는 포함하는 객체를 참조합니다.
		this.result = this.operandl + this.operand2;
	}
}；
calculator.add(); // 메서드 호출을 통해 1 + 1을 계산합니다.
calculator.result // => 2

o["m"](x,y); // o.m(x,y)와 동등합니다.
a[0](z) // a[0]o| 함수라면 역시 메서드 호출입니다.
customer.surname.toUpperCase(); // customer.surname의 메서드를 호출합니다.
f().m(); // f()의 반환 값의 메서드인 m()을 호출합니다.
```

메서드와 this 키워드는 객체 지향 프로그래밍 패러다임의 핵심이다. 메서드로 사용되는 함수는 모두 자신을 호출하는 객체를 묵시적인 인자로 받는다. 메서드는 일반적으로 그 객체에서 동작하며, 메서드 호출 문법은 함수가 객체에서 동작한다는 의미를 명쾌하게 전달한다. 

```jsx
rect.setSize(width, height);
setRectSize(rect, width, height);
```

<aside>
💡 메서드 체인

메서드가 객체를 반환하면 그 반환 값에서 다시 메서드를 호출할 수 있다. 이렇게 메서드 호출을 ‘체인’으로 이어서 표현식 하나로 만들 수 있다. 프로미스 기반 비동기 동작을 구성할 때 다음과 같은 코드를 자주 사용한다.

```jsx
// 세 가지 비동기 동작을 순서대로 실행하고 에러를 처리합니다.
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);
```

반환 값이 필요 없는 메서드를 작성할 때는 메서드가 this를 반환하도록 한다. API 전체에서 일관되게 this를 반환한다면 메서드 체인이라는 프로그래밍 스타일을 따를 수 있다. 이런 스타일에서는 다음과 같이 객체를 한 번만 참조하고도 연속으로 메서드를 호출할 수 있다.

```jsx
new Square().x(100).y(100).size(50).outline("red").fill("blue").draw();
```

</aside>

this는 변수나 프로퍼티 이름이 아니라 키워드이다. 자바스크립트 문법은 this 에 값을 할당하는 것을 허용하지 않는다.

this 키워드는 변수의 스코프 규칙을 따르지 않는다. 화살표 함수의 예외를 제외하면 중첩 된 함수는 포함하는 함수의 this 값을 상속하지 않는다. 중첩 된 함수를 메서드로 호출하면 그 this 값은 호출한 객체이다.

(화살표 함수가 아닌) 중첩 된 함수를 함수로 호출하면 그 this 값은 일반 모드에서는 전역 객체이고, 스트릭 트 모드에서는 undefined이다.

메서드 안에 정의된 함수를 함수로 호출하면 this를 통해 메서드의 호출 컨텍스트를 참조할 수 있다고 생각하기도 하는데, 이는 흔히 저지르는 실수이다.

```jsx
let o = { // 객체 o
	m: function() { // 객체의 메서드 m
		let self = this; // this 값을 변수에 저장합니다.
		this === o // => true: this는 객체 o입니다.
		f(); // 보조 함수 f()를 호출합니다.

		function f() { // 중첩된 함수 f
			this === o // => false: this는 전역 객체이거나 undefined입니다.
			self === o // => true: self는 외부 this 값입니다.
		}
	}
};

o.m(); // 객체 o에서 메서드 m을 호출합니다.
```

중첩된 함수 f()에서 this 키워드는 객체 o와 같지 않다. 자바스크립트 언어의 결함으로 지적받는 부분이고, 반드시 인지하고 있어야 한다.

위 코드는 널리 쓰이는 우회 방법을 제시한다. 메서드 m 안에서 this 값을 변수 self에 할당 하면, 중첩 된 함수 f 안에서 포함하는 객체를 this 대신 self로 참조할 수 있다.

ES6 이후에는 중첩된 함수 f를 화살표 함수로 변환해 this 값을 상속하게 하는 방법도 가능하다.

```jsx
const f = () => {
	this === o // true: 화살표 함수는 항상 this를 상속합니다.
};
```

표현식으로 정의된 함수는 끌어올려지지 않으므로 이 코드가 동작하기 위해서는 메서드 m 안에서 f를 정의하는 부분을 호출 이전으로 옮겨야 한다.

```jsx
const f = (function() {
	this === o // true: 이 함수를 외부 this와 연결했습니다.
}). bind(this);
```

중첩된 함수의 bind() 메서드를 호출해 지정된 객체에서 묵시적으로 호출되는 새 함수를 정의하는 방법도 있다.

### 생성자로 호출

생성자 호출에서는 빈 괄호를 생략해도 된다.

```jsx
o = new Object();
o = new Object;
```

생성자 호출이 메서드 호출처럼 보이더라도 호출 컨텍스트는 새 객체이다. 즉, 표현식 new o.m()에서 o는 호출 컨텍스트로 사용되지 않는다.

생성자 함수는 일반적으로 return 키워드를 사용하지 않는다. 생성자 함수는 일반적으로 새 객체를 초기화하며 함수 바디의 끝에 도달하면 종료한다. 이 경우 새 객체가 생성자 호출 표현식의 값이다.

생성자가 명시적으로 return 문을 사용해 객체를 반환한다면 그 객체가 호출 표현식의 값이 된다. 생성자가 return 문을 값 없이 사용하거나 기본 값을 반환한다면 반환 값을 무시하고 새 객체를 호출 표현식의 값으로 사용한다.

### call(), apply() 메서드를 통해 간접적으로 호출

call()과 apply()는 함수를 간접적으로 호출한다.

두 메서드 모두 호출 시점에 this 값을 직접 명시할 수 있으므로, 함수를 어떤 객체의 메서드로도 호출할 수 있다. call() 메서드는 인자 리스트를 받고 apply() 메서드 는 인자로 배열을 받는다.

### 자바스크립트 언어 기능을 통한 묵시적 호출

자바스크립트에는 함수 호줄처럼 보이지 않지만 함수를 호줄하는 기능이 여럿 존재한다. 묵시적으로 호출한 함수에서 버그, 부작용, 성능 문제가 발생한다면, 단순히 코드를 들여다보는 것으로는 언제 호출되는지 명확히 알기 어려우므로 일반 적인 함수에 비해 해결하기가 훨씬 어렵다.

객체에 게터나 세터가 있다면 프로퍼티 값에 접근할 때 이 메서드가 호출될 수 있다.

문자열을 받는 컨텍스트에 객체를 사용하면 toString() 메서드가 호출된다. 마찬가지로, 객체를 숫자 컨텍스트에 사용하면 valueOf() 메서드가 호출된다.

이터러블 객체의 요소를 순회할 때 여러가지 메서드가 호출될 수 있다.

태그된 템플릿 리터럴도 함수 호출을 일으킬 수 있다. 

프록시 객체는 완전히 함수에 의해 제어됩니다. 어떤 동작을 취하든 항상 함수가 호줄된다.

## 함수 매개변수

자바스크립트 함수는 매개변수로 어떤 타입을 받는지 정의하지 않으며, 함수 호출 시점에서도 전달받은 값의 타입을 체크하지 않는다. 자바스크립트는 함수를 호 출할 때 전달받은 인자의 개수조차 체크하지 않는다.

### 선택 사항인 매개변수와 기본 값

```jsx
// 객체 o의 열거 가능한 프로퍼티를 배열 a에 추가하고 a를 반환합니다.
// a를 생략하면 새 배열을 생성해 반환합니다.
function getPropertyNames(o, a) {
		if (a === undefined) a = []; // 정의되지 않았으면 새 배열을 사용합니다.
		// a = a || [];
		for(let property in o) a.push(property);
		return a;
}
// getPropertyNames()는 인자 한 개나 두 개로 호출할 수 있습니다.
let o = {x: 1}, p = {y: 2, z: 3}; // 테스트용 객체
let a = getPropertyNames(o); // a == ["x"]; o의 프로퍼티를 새 배열에 담습니다.
getPropertyNames(p, a); // a == ["x","y","z"]; p의 프로퍼티를 추가합니다.
```

ES6 이후에는 함수를 정의할 때 함수 매개변수의 기본 값을 정의할 수 있다. 매개변수 이름 뒤에 등호(=)를 쓰고, 그 매개변수가 생략됐을 때 사용할 기본 값을 쓴다.

```jsx
// 객체 o의 열거 가능한 프로퍼티를 배열 a에 추가하고 a를 반환합니다.
// a를 생략하면 새 배열을 생성해 반환합니다.
function getPropertyNames(o； a = []) {
	for(let property in o) a.push(property);
	return a;
}

// 이 함수는 사각형의 크기를 나타내는 객체를 반환합니다.
// 너비가 제공됐을 때만 높이를 너비의 두 배로 정합니다.
const rectangle = (width, height = width * 2) => ({width, height});
rectangle(1) // => { width: 1, height: 2 }
```

매개변수 기본 값 표현식은 함수를 정의할 때가 아니라 호출할 때 평가된다. 따라서 getPropertyNames() 함수를 인자 하나로 호출할 때마다 빈 배열을 새로 생성 해서 전달한다.

### 나머지 매개변수와 가변 길이 인자 리스트

매개변수 기본 값을 사용하면 정의된 매개변수보다 적은 인자를 써서 함수를 호출 할 수 있다.

반대로 정의된 매개변수 보다 더 많은 인자를 써서 함수를 호출할 수도 있다.

```jsx
function max(first=-Infinity, ...rest) {
	let maxValue = first; // 첫 번째 인자가 가장 크다고 가정합니다.
	// 나머지 인자를 순회하면서 더 큰 값을 찾습니다.
	for(let n of rest) {
		if (n > maxValue) {
			maxValue = n;
		}
	}
	// 가장 큰 값을 반환합니다.
	return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6) // => 1000
```

함수 바디 안에서 나머지 매개변수의 값은 항상 배열이다. 배열이 비어 있더라도 나머지 매개변수는 절 대 undefined가 되지 않는다. 따라서 나머지 매개변수에 매개변수 기본 값을 지 정할 필요도 없고, 허용되지도 않는다.

앞의 예제처럼 인자 개수에 제한이 없는 함수를 가변 함수(variadic function, variable arity function, vararg function)라고 부른다.

### Argument 객체

나머지 매개변수는 ES6에서 자바스크립트에 도입했다. ES6 전에는 Arguments 객체를 써서 가변 함수를 만들었다. 함수 바디 안에서 식별자 arguments는 해당 호출의 Arguments 객체를 참조한다.

```jsx
function max(x) {
	let maxValue = -Infinity;
	// 인자를 순회하며 가장 큰 값을 찾아 기억합니다.
	for(let i = 0; i < arguments.length; i++) {
	if (arguments[i] > maxValue)
		maxValue = arguments[i];
	}
	// 가장 큰 값을 반환합니다.
	return maxValue;
}
max(l, 10, 100, 2, 3, 1000, 4, 5, 6) // => 1000
```

Arguments 객체는 자바스크립트 초기 버전부터 있었지만, 좀 이상하게 동작하고 비효율적이며 최적화하기도 어다. 여전히 Arguments 객체가 포함된 코드를 볼 수 있겠지만, 새로 작성하는 코드에는 사용하지 말아야 한다.

스트릭트 모드에서는 arguments를 예약어로 취급하므로 이 이름을 써서 함수 매개변수나 로컬 변수를 선언할 수 없다.

### 함수 호출과 분해 연산자

분해 연산자 ...는 개별 값이 예상되는 컨텍스트에서 배열이나 문자열 같은 이터러블 객체를 분해한다.

```jsx
let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers) // => -1
```

...는 평가를 통해 값을 얻을 수 없다는 점에서 진정한 연산자로는 볼 수 없다. ...는 배열 리터럴과 함수 호출에 사용할 수 있는 특별한 자바스크립트 문법이다.

```jsx
// 이 함수는 함수를 받아 래퍼 버전을 반환합니다.
function timed(f) {
	return function(...args) { // 인자를 나머지 매개변수 배열에 모읍니다.
		console.log(`Entering function ${f.name}`);
		let startTime = Date.now();
		try {
			// 인자를 모두 래퍼 버전에 전달합니다.
			return f(...args); // 인자를 다시 분해합니다.
		}
		finally {
			// 반환하기 전에 소요된 시간을 출력합니다.
			console.log(`Exiting ${f.name} after ${Date.now()-startTime}ms`);
		}
	};
}

// 1 과 n 사이의 숫자의 합을 계산합니다.
function benchmark(n) {
	let sum = 0;
	for(let i = 1; i <= n; i++) sum += i;
	return sum;
}

// 테스트 함수의 래퍼 버전을 호출합니다.
timed(benchmark)(1000000) // => 500000500000; 숫자의 합입니다.
```

### 함수 인자를 매개변수로 분해

함수를 호출할 때 전달한 인자는 함수 정의 시 선언된 매개변수에 할당된다.

함수를 정의할 때 매개변수 이름을 대괄호 안에 쓰면, 대괄호 한 쌍마다 배열 값을 받는다고 정의하게 된다.

```jsx
function vectorAdd(v1, v2) {
	return [v1[0] + v2[0], vl[l] + v2[l]];
}
vectorAdd([1,2], [3,4]) // => [4,6]

function vectorAdd([x1,y1], [x2,y2]) { // 인자 두 개를 매개변수 네 개로 분해합니다.
	return [x1 + x2, y1 + y2];
}
vectorAdd([1,2], [3,4]) // => [4,6]
```

객체 인자를 받는 함수를 정의할 때도 인사로 받은 객체를 매개변수로 분해할 수 있다.

```jsx
// 스칼라 값을 벡터에 곱합니다.
function vectorMultiply({x, y}, scalar) {
	return { x: x * scalar, y: y * scalar };
}
vectorMultiply({x: 1, y: 2}, 2) // => {x: 2, y: 4}

function vectorAdd(
	{x: x1, y: y1}, // 첫 번째 객체를 xl과 yl 매개변수로 분해합니다.
	{x: x2, y: y2} // 두 번째 객체를 x2와 y2 매개변수로 분해합니다.
) {
	return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({x: 1, y: 2}, {x: 3, y: 4}) // => {x: 4, y: 6}

// {x,y} 또는 {x,y,z} 벡터에 스칼라 값을 곱합니다.
function vectorMultiply({x, y, z = 0}, scalar) {
	return { x: x * scalar, y: y * scalar, z: z * scalar };
}
vectorMultiply({x: 1, y: 2}, 2) // => {x: 2, y: 4, z: 0}
```

매개변수가 만약 많다면 인자 순서를 정확히 기억하기는 어렵다. 이럴 때는 다음과 같이 정의하면 한결 사용하기 쉬워진다.

```jsx
function arraycopy({from, to=from, n=from.length, fromlndex=0, tolndex=0}) {
	let valuesToCopy = from.slice(fromlndex, fromlndex + n);
	to.splice(tolndex, 0, ...valuesToCopy);
	return to;
}
let a = [1,2,3,4,5], b = [9,8,7,6,5];
arraycopy({from: a, n: 3, to: b, tolndex: 4}) // => [9,8,7,6,1,2,3,5]
```

배열을 분해하고 남은 값으로도 나머지 매개변수를 정의할 수 있다.

```jsx
// 이 함수는 배열 인자를 받습니다. 배열의 첫 번째와 두 번째 요소는 X와 y 매개변수에 // 할당됩니다. 남는 요소는 모두 coords 배열에 저장됩니다. 첫 번째 배열을 제외한 // 인자는 모두 rest 배열에 저장됩니다.
function f([x, y, ...coords], ...rest) {
	return [x + y, ...rest, ...coords]; // 분해 연산자를 썼습니다.
}
f([1, 2, 3, 4], 5, 6) // => [3, 5, 6, 3, 4]
```

ES2018부터는 객체를 분해할 때도 나머지 매개변수를 사용할 수 있다.

```jsx
// {x,y} 또는 {x,y,z} 벡터에 스칼라 값을 곱하고 다른 프로퍼티는 유지합니다.
function vectorMultiply({x, y, z=0, ...props}, scalar) {
	return { x: x * scalar, y: y * scalar, z: z * scalar, ...props };
}
vectorMultiply({x: 1, y: 2, w: -1}, 2) // => {x: 2, y: 4, z: 0, w: -1}
```

객체와 배열 인자만 분해할 수 있는 것은 아니다. 객제 배열, 배열 프로퍼티를 가진 객체, 객체 프로퍼티를 가진 객체 모두 분해할 수 있으며 그 깊이에 제한은 없다.

```jsx
function drawCircle({x, y, radius, color: [r, g, b]}) {
// 함수 바디
}
```

함수 인자 분해가 이보다 더 복잡하다면 코드가 간결해서 얻는 장점보다 읽기 어려워서 생기는 단점이 더 클 것이다. 객체 프로퍼티나 배열 인덱스로 접근하는 편이 더 명확할 때도 있다.

### 인자 타입

자바스크립트 메서드는 매개변수 타입을 선언하지 않으며 값을 전달할 때도 타입을 체크하지 않는다. 함수 인자에 뜻이 분명한 이름을 쓰고, 함수에 주석을 달아 두면 코드 자체가 문서가 될 수 있다.

```jsx
// 이터러블 객체 a의 요소 합계를 반환합니다. 요소는 모두 반드시 숫자여야 합니다.
function sum(a) {
	let total = 0;
	for (let element of a) { // a 가 이터러블이 아니면 TypeError가 일어납니다.
		if (typeof element !== "number") {
			throw new TypeError("sum(): elements must be numbers");
		}
		total += element;
	}
	return total;
}
sum([1,2,3]) // =그 6
sum(1, 2, 3); // TypeError: 1 은 이터러블이 아닙니다.
sum([1,2,"3"]); // TypeError: 인덱스 2는 숫자가 아닙니다.
```

## 값인 함수

### 함수 프로퍼티 직접 정의

## 네임스페이스인 함수

## 클로저

## 함수 프로퍼티, 메서드, 생성자

### length

### name

### prototype

### call()과 apply()

### bind()

### toString()

### Function()

## 함수형 프로그래밍

### 함수로 배열 처리

### 고계 함수

### 함수의 부분 적용

### 메모이제이션