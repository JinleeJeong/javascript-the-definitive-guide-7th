

# 3장 타입, 값, 변수

이 장에서는 자바스크립트의 타입, 값, 변수에 대해 설명함

# 3.1 개요와 정의

자바스크립트 타입은 `기본 타입` 과 `객체 타입` 으로 나뉨

**기본 타입**
- 숫자
- 문자열
- 불 (boolean)
- null
- undefined
- Symbol (ES6)

**객체 타입**
- Object


기본 타입에 속하지 않는 것은 모두 `객체` 이며, 이름 붙은 값의 순서가 없는 집합


**자주 사용되는 객체 타입**
- Array
- Set
- Map
- RegExp
- Date
- Error

함수, 클래스 또한 객체

---


인터프리터는 자동으로 가비지 컬렉션(GC)를 수행해 메모리를 관리함

따라서, 개발자가 직접 컨트롤 하지 않음.

프로그램에서 더 이상 참조하지 않으면 GC가 다시 메모리를 확보함

---

객체 지향 프로그래밍 스타일을 지원함

배열의 요소를 정렬하는 함수를 예로

`a.sort(); // sort(a) 의 객체 지향 버전`

---

메서드는 오직 객체에서만 가질 수 있음

하지만 숫자, 문자열, 불 심벌도 메서드가 있는 것 처럼 동작

---

객체 타입은 가변이며, 기본 타입은 불변임

---

타입 변환이 자유롭다.

예로, 문자열에 와야하는 곳에 숫자가 오면 자동으로 문자열로 변환 처리 함

Boolean이 와야 하는 곳에 boolean이 아닌 값이 오면 규칙에 맞게 변환시킴



# 3.2 숫자

정수와 함께 실수를 대략적으로 표현하는 타입 (Number)

`IEEE 754` 표준에서 정의하는 64비트 부동 소수점 형식을 사용

`최대 ±1.7976931348623157 x 10%, 최소 +5 × 107-24`

`-9,007,199,254,740,992(-2^53)` 이상, `9,007,199,254,740,992(2^53)` 
이하 범위의 정수를 정확히 표현


이 보다 큰 정수 값을 사용하는 경우 정확도 가 떨어질 수 있음

일부 자바스크립트 연산은 32비트 정수를 사용, 더 큰 정수를 사용하려 `BigInt` 를 사용

# 3.2.1 정수 리터럴

16진수 정수 리터럴 예

```
Oxff      // => 255; (15*16 + 15)
0xBADCAFE // => 195939070
```

ES6 이후 0b(0B) 를 사용하는 2진수, 0o(0O)를 사용하는 8진수 표현 가능

```
Ob10101 // => 21; (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
00377   // => 255; (3*64+7*8+7+1)
```

# 3.2.2 부동 소수점 리터럴

부동 소수점 리터럴에는 소수점이 포함될 수 있음

표기법은 실수 다음에 e(E)를 쓰고 플러스 혹은 마이너스 기호, 마지막으로 지수를 나타내는 정수를 쓰는 형식


`[digits][.digits][(E|e)[(+|-)]digits]`


예)
```
3.14
2345.6789
.333333333333333333  
6.02e23       // 6.02 x 10^23
1.4738223E-32 // 1.4738223 x 10^-32
```


숫자 리터럴 구분자도 존재

```
let billion = 1_000_000_000;  // 밑줄을 천 단위 구분자로 썼습니다. 
let bytes = 0x89_AB_CD_EF;    // 바이트 구분자로 썼습니다.  
let bits = 0b0001_1101_0111;  // 4비트 구분자로 썼습니다.
let fraction = 0.123_456_789; // 소수점 아래 부분에도 쓸 수 있습니다.
```

# 3.2.3 자바스크립트의 산술 연산

`+-*/%` 와 ES2016의 `**` 지수 표현이 추가 됨

Math 객체를 이용하여 복잡한 수학 계산

ES6에서 Math 객체 함수들이 추가 됨

자주 사용할만한 `Math.trunc(3.9) // => 3: 소수점 아래를 잘라 내어 정수로 변환합니다.` 도 ES6에서 추가 된 함수


# 3.2.4 이진 부동 소수점 숫자와 반올림 오류

자바스크립트가 부동 소수점 형식으로 정확히 표현할 수 있는 숫자는 유한함
`18,437,736,874,454,810,627개`


`IEEE 754` 부동 소수점 표현은 이진 표현이라 `1/2, 1/8, 1/1024` 는 정확히 표현함

하지만. `1/10, 1/100` 같은 숫자는 정확히 표현하지 못함

예
```
let x = 3 - .2;   // 0.3 빼기 0.2
let y = .2 - .1;  // 0.2 빼기 0.1
X==y              //=>false: 두값은같지않습니다! 
X=== .1.          // => false: 0.3 - 0.2는 0.1과 같지 않습니다.
y === 1.          // => true: 0.2 - 0.1은 0.1입니다.
```


반올림 오류 때문에 `0.3` 과 `0.2` 차이의 근삿값은 `0.2` 와 `0.1` 의 차이의 근삿값과 같지 않음

부동 소수점 근삿값 때문에 문제가 생긴다면 정수로 변환하는 것을 고려

예로 `0.1` 달러 대신 `10` 센트로 계산


# 3.2.5 BigInt로 임의 정확도를 부여한 정수

ES2020에서 추가된 `BigInt는` 값이 정수인 숫자 타입

64비트의 정수를 표현하기 위해 추가됨

`BigInt`는 타이밍 공격을 방지할 수 없으므로 암호화에는 사용할 수 없음

---

`BigInt` 리터럴은 연속된 숫자 다음에 소문자 n을 붙인 형식

- `0b` 이진수
- `0o` 8진수
- `0x` 16진수 
```
1234n                // 그렇게 크지는 않은 BigInt 리터럴
06111111n            // 이진 BigInt  
007777n              // 8진 BigInt
0x8000000000000000n  // => 2n*63n: 64비트 정수
```

---

`BigInt()` 함수를 사용하여 자바스크립트 숫자나 문자열을 `BigInt` 로 변환 가능

`BigInt` 산술 연산은 나눗셈을 할 때 나머지를 버림

`BigInt` 는 일반적인 숫자 피연산자를 섞어 사용할 수 없음

하지만, 비교 연산자는 피연사자를 섞어도 괜찮음

```
1 <2n     // => true
2> 1n     // => true
0 == On   // => true
0 === On  // => false: ===는 타입까지 같은지 체크합니다.
```

비트 연산자도 `BigInt`를 피연산자로 받을 수 있음

`Math` 객체의 함수는 `BigInt`를 피연산자로 받을 수 없음


# 3.2.6 날짜와 시간

`Date` 클래스를 이용하여 날짜와 시간에 대응하는 숫자를 표현, 조작 가능

`Date는` 객체이지만 타임스탬프인 숫자 표현도 가지고 있어 `1970년 1월 1일`로 부터 몇 밀리초가 지났는지 계산 가능


# 3.3 텍스트

자바스크립트에서는 텍스트를 표현하는 타입은 문자열

문자열을 16비트 값이 순서에따라 이어진 형태이며, 기본 값이므로 불변

각 값은 일반적으로 유니코드

# 3.3.1 문자열 리터럴

ES6에서 백틱으로 감싼 문자열 기능이 추가 됨

문자열 리터럴 안에 자바스크립트 표현식을 넣을 수 있고, 이 문법을 보간(interpolation) 이라고 함

자바스크립트 코드에 HTML 문자열이 들어갈 수 있고, HTML 안에 자바스크립트 코드가 들어갈 수 있으므로, 작은 따음표와 큰 따옴표를 구분하는 규칙이 필요


`<button onclick="alert('Thank you')">Click Me</button>`


# 3.3.2 문자열 리터럴 안의 이스케이프 시퀀스

`\` 와 다른 문자를 조합하여 일반적으로 문자열에 표시할 수 없는 문자

예를 들어 작은 따옴표안에 작은 따옴표를 쓰고 싶은 경우

`'You\'re right, it can\'t be a quote'` 같이 표현할 수 있다

유니코드의 경우
- `\unnnn` (16진수 숫자 네개를 nnnn로 유니코드를 표현)
-  `\u{n}` (n은 0~10FFF 범위의 16진수 숫자)

예로 `\u{1f600}`은 웃는 이모지


자바스크립트에서 제공하지 않는 문자와 역슬래시를 조합하면 역슬래시가 무시됨

예로
`\#`, `\` 는 같은 문자


# 3.3.3 문자열 다루기



문자열은 기본적으로 `+`로 문자열들을 연결할 수 있음

비교할 때는 일치 연산자 `===`, `!==` 가 표준, 두 문자열이 정확히 같은 16비트 값의 연속으로 이루어졌을 때 일치

문자열을 `<, <=, >, >=` 로 비교할 수 있음

비교는 16비트 값을 비교하는 방식

문자열을 여러 API가 내장 되어있음


예로
`s.slice(1,4)` 와 같이 문자열에 내장되어 있는 API를 사용할 수 있음

---

자바스크립트 문자열은 불변이며, `replace()`, `toUpperCase()` 같은 메서드는 문자열을 수정하는 것이 아니라 새 문자열을 반환함

문자열을 읽기 전용 배열로 취급하기위해 `charAt()` 같은 메서드로 문자열의 개별 문자에 접근 할 수 있음


# 3.3.4 템플릿 리터럴


ES6 부터 추가된 백틱으로 감싼 문자열 리터럴

일반 문자열 리터럴 문법과 다르게 문자열안에 `표현식`을 넣을 수 있음

```
let name = "Bill";  
letgreeting = `Hello${name}.`; //greeting == "HelloBill."
```

---

템플릿 리터럴 앞에 함수 이름(태그)가 있으면 템플릿 리터럴의 텍스트와 표현식이 함수로 전달됨

HTML이나 SQL를 이스케이프하는 용도로 사용 가능

ES6의 `String.raw()` 는 함수의 역슬래시 이스케이프를 처리하지 않고 백틱안의 텍스트를 반환함


```
`n`.length            // => 1: 이 문자열에는 뉴라인 문자 하나만 있습니다.
String.raw`\n`.length // => 2: 역슬래시 문자와 n
```

괄호 없이 함수를 하는 방식

# 3.3.5 패턴 매칭

`RegExp` (정규 표현식) 이라는 데이터 타입이 존재

기본적인 데이터 타입은 아니지만 리터럴 문법이 존재

슬래시 한 쌍 사이에 텍스트를 쓰는 형태

두 번째 뒤에 오는 글자 하나는 패턴의 의미를 수정함

```
/^HTML/;            // 문자열의 시작 부분에 있는 HTML에 일치합니다.  
/[1-9][0-9]*/;      // 0이 아닌 숫자가 하나 있어야 하고 그 뒤의 숫자는 제한이 없습니다.
/\bjavascript\b/i;  // javascript가 한 단어로 들어가야 하고 대소문자를 구분하지 않습니다.
```

`RegExp` 객체에는 여러 메서드가 존재하며 문자열역시 RegExp 인자를 받는 메서드가 있음


# 3.4 불 값

`true` , `false` 두 가지 예약어로 존재하는 타입

```
undefined
null
0
-0
NaN
"" // 빈 문자열
```

위의 값들은 모두 `false` 로 처리되며 `false` 처럼 동작하고 `falsy` 한 값이라 부르고 이외의 값을 `truthy` 라 부름



# 3.5 null과 undefined


`null` 은 값이 없음을 나타내는 특별한 값

`null` 에 `typeof` 로 검사하면 `object` 문자열을 반환하는데, 따라서 `null` 은 객체가 없다라고 나타내는 특별한 객체 값임

---

`undefined` 는 값이 없음을 나타내지만, 초기화되지 않은 변수의 값임

존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을 때 반환되는 값

`undefined` 는 `typeof` 로 검사하면 `undefined` 문자열을 반환하는데 이것은 `undefined` 가 특별한 타입이고 멤버는 그 하나뿐임



# 3.6 심벌


ES6 이전에는 객체의 각 프로퍼티는 일반적이 문자열이었으나 ES6 에 추가 된 심벌은 이러한 프로퍼티 처럼 특별한 프로퍼티 값으로 사용할 수 있음

심벌 타입에는 리터럴 문법이 없으며, 심벌 값을 가져올 때는 `Symbol()` 함수를 호출함

특징으로는, 같은 인자로 호출하더라도 다른 값을 반환하는데 이것은 프로퍼티를 같은 이름으로 덮어 쓰지 않고 프로퍼티를 추가할 수 있음

---

ES6에 도입된 이유는 `for/of` 루프나 이터러블 객체를 도입할 때 클래스가 자기 자신을 이터러블로 만들 수 있는 표준 메서드를 정의해야 했는데, 특정 문자열 이름으로 이터레이터 메서드를 표준화하면 기존 코드가 깨지기 때문이었음


예로 `Symbol.iterator` 는 객체를 이터러블로 만드는 메서드 이름으로 쓸 수 있는 심벌 값

---

`Symbol()` 함수는 인자로 문자열을 받고 고유한 심벌 값을 반환함

따라서 같은 문자열을 전달해 `Symbol()` 을 다시 호출하더라도 결과값이 다름

```
let s = Symbol("sym_x"); 

s.toString()             // => "Symbol(sym_x)"
```

`toString()` 은 심벌 인스턴스의 메서드

---

심벌을 다른 코드의 프로퍼티와 충돌하지 않게 하고 싶거나, 다른 코드에서 쓸 수 있도록 심벌을 정의하고 공유하고 싶은데, 후자의 경우 `Symbol.iterator` 같은 메커니즘으로 확장할 수 있음

이러한 것을 전역 심벌 레지스트리라 하며 `Symbol.for()` 를 사용함 

```
let s = Symbol.for("shared");
let t = Symbol.for("shared");
s ===t                         // => true
s.toString()                   // => "Symbol(shared)"
Symbol.keyFor(t)               // => "shared
```


# 3.7 전역 객체


전역 개체의 프로퍼티는 전역으로 정의된 식별자이며 모든 자바스크립트 프로그램에서 사용 가능

🌠
자바스크립트 인터프리터를 시작 할 때마다 (웹 브라우저가 새 페이지를 로드할 때마다) 다음과 같은 프로퍼티를 가진 새 전역 객체를 생성함

```
• undefined, Infinity, NaN 같은 전역 상수  
• isNaN(), parseInt()(3.9.2절), eval()(4.12절) 같은 전역 함수
• Date(), RegExp(), String(), Object(), Array()(3.9.2절) 같은 생성자 함수
• Math와 JSON(6.8절) 같은 전역 객체
```

전역 개체의 초기 프로퍼티는 예약어가 아니지만 예약어로 간주 해야 함

---

노드의 경우 `global` 프로퍼티가 존재하며 이 값은 전역 객체 자체

웹 브라우저의 경우 `Window` 객체가 모든 자바스크립트 코드의 전역 객체이며 이 객체는 자신을 참조하는 `window` 프로퍼티가 있어 이 전역 객체를 참조할 수 있음

Window 객체에는 핵심 전역 프로퍼티가 정의되어 있으며, 해당 웹 브라우저와 클라이언트 사이드 자바스크립트에 밀전합 전역 변수도 정의 되어 있음

하지만 웹 워커 스레드의 전역 객체와는 다름, 워커의 코드는 `self` 로 전역 객체를 참조함

---

ES2020에서 정의한 `globalThis` 는 어떠 환경에서든 전역 객체를 참조함

# 3.8 불변인 기본 값과 가변인 객체 참조


기본 값과 객체의 큰 차이 중 하나는 기본 값은 불변임

기본 값을 `변경` 하는 방법은 없음

하지만, 문자열에서는 이게 명백하게 느껴지지 않을 수 있음

문자열은 문자의 배열이므로 특정 인덱스의 문자를 바꿀 수 있다고 느껴지지만 이는 허용되지 않으며 사실 메서드가 수정된 문자열을 반환하는 것 처럼 보이지만 실제로는 새 문자열 값을 반환 하는 것

```
let s = "hello";    // 소문자 텍스트로 시작합니다.  
s.toUpperCase();    // HELLO를 반환하지만 S는 그대로입니다.  
s                   // => "hello": 원래 문자열은 변하지 않았습니다.
```

기본 값은 값으로 비교하며 일치하려면 값이 같아야 함, 다른 기본 값에서는 명확하지만 문자열의 경우 조금 다르게 느껴질 수 있음

두 개의 문자열 값을 비교할 때는 두 문자열의 길이가 같고 각 인데스마다 같은 문자가 있어야 같은 것으로 취급함

---

객체는 값으로 비교하지 않으며 두 객체의 프로터피의 값이 같다고 해서 같은 객체가 아님, 또한 배열도 같은 요소가 같은 순서로 존재한다 해도 같은 배열이 아님

```
let o = {x: 1}, p = {x: 1}; //프로퍼티가 같은 두 객체
0 === p                // => false: 별개의 객체가 일치할 수는 없음
let a = 0, b = [];     // 별개인 두 빈 배열
a === b                // => false: 별개의 배열이 일치할 수는 없음
```

---

객체는 참조로 비교하므로 두 객체의 값이 같다는 것은 오직 두 값이 같은 객체를 참조할 때 성립함

```
let a = [];      // 변수 a는 빈 배열을 가리킵니다.  
let b = a;       // 이제 변수 b도 같은 배열을 가리킵니다.
b[0] = 1;        // b가 참조하는 배열을 변경합니다.  
a[0]             // => 1: 바뀐 부분은 변수 a를 통해서도 보입니다. 
a === b           // => true: a와 b는 같은 객체를 참조하므로 같은 값입니다.
```

위를 보듯 객체나 배열을 변수에 할당하는 것은 참조를 할당 하는 것

객체나 배열의 사본을 만들기 위해서는 객체 프로퍼티나 배열 요소를 직접 복사해야 함


# 3.9 타입 변환


자바스크립트는 타입을 강제하지 않으며 필요에 맞게 자동으로 변환함

숫자로 인식할 수 있는 문자열은 그 숫자로 변환하는데, 앞뒤에 스페이스는 허용하지만, 숫자 리터럴이 아닌 문자가 앞뒤에 있다면 `NaN` 으로 변환함

`true` 는 `1`, `false`와 빈 문자열은 `0`으로 변환되는 등 일부의 특이 케이스들이 존재


# 3.9.1 변환과 일치


동등 연사자 `==` 와 일치 연산자 `===` 로 두 값이 일치하는지 테스트하는 연사자가 있지만 일치 연산자를 사용한것이 거의 항상 좋음


# 3.9.2 명시적 변환


명시적으로 타입을 변환하는 기본적인 방법은 `Booelan(), Number(), String()` 등의 함수가 있음

`null, undefined` 를 제외한 모든 값에는 `toString()` 메서드가 있으며 결과는 보통 `String()` 함수의 반환값과 같음

---

묵시적으로 타입을 변환할 수도 있는데 아래와 같음

```
x + ""  // => String(x)
+x    // => Number(x)
x-0    // => Number(x)
!!x    // => Boolean(x): !가 두 개입니다.
```

---

`Number` 클래스의 `toString()` 메서드는 선택적으로 기수를 인자를 받음

인자를 생략하면 10진수로 변환하며 2이상 36이하의 기수를 넘겨 변환할 수 있음

`Number` 클래스의 `toFixed()` 메서드 숫자를 변활할 때 소수점 아래 몇 자리를 표시하지 지정할 수 있음

# 3.9.3 객체를 기본 값으로 변환

객체를 기본 값으로 변환하는 규칙이 있는데 아래의 세 가지 기본적인 알고리즘으로 정의되어 있음


## 문자열 선호
기본 값을 반환할 때 문자열로 변환할 수 있다면 문자열 값을 우선 함


## 숫자 선호
기본 값을 반환할 때 숫자로 변환할 수 있다면 숫자 값을 우선 함


## 선호 없음
- 기본 타입을 선호하는지 정해 놓지 않았으며 클래스에서 변환 방법을 정의 할 수 있음
- `Date` 를 제외한 모든 타입이 이 알고리즘에 숫자 선호를 적용함, `Date` 클래스는 문자열 선호를 적용함


---

위 세가지 알고리즘을 아래와 같이 적용함

## 객체를 불로 변환
- 객체는 모두 `true` 로 변환 됨
- 빈 배열, 래퍼 객체 `new Boolean(false)` 역시 `true`


## 객체를 문자열로 변환
- 객체를 문자열로 변환해야 할 때는 먼저 문자열 선호 알고리즘을 사용해 기본 값으로 변환한 다음, 규칙(자바스크립트 타입 변환)에 따라 기본 값을 문자열로 변환함
- 문자열 인자를 예상하는 내장 함수에 객체를 전달 하거나, `String()` 을 변환 함수로 호출 할 때, 템플릿 리터럴에 객체를 사용할 때 이 변환에 해당함


## 객체를 숫자로 변환
- 객체를 숫자로 변환해야 할 때는 숫자 선호 알고리즘에 따라 기본 값으로 변환한 다음 규칙(자바스크립트 타입 변환)에 따라 기본 값을 숫자로 변환
- 숫자 인자를 예상하는 내장 함수에 객체를 전달 하거나, 메서드가 객체를 받았을 때 이 방법을 사용하여 숫자로 변환


## 특별한 케이스인 연산자 변환
- `+` 연사자는 숫자를 더하고 문자열을 병합함
- `+` 연산자의 피연산자 중 하나가 객체라면 해당 피연산자를 선호 없을 알고리즘에 따라 기본 값으로 변환함
- 피연산자 중 하나라도 문자열이면 다른 하나도 문자열로 변환한 다음 병합함
- 피연산자가 모두 문자열이 아니라면 둘 다 숫자로 변환한 다음 더함
- `==` , `!=` 연사자는 타입 변환을 허용, 피연산자 중 하나가 객체이고 다른하나가 기본 값이라면 선호 없을 알고리즘을 사용하여 객체를 기본 값으로 변환한 다음 비교
- 관계 연산자 `<`, `<=` , `>`, `>=` 는 피연산자의 순서를 비교하며 숫자와 문자열을 비교하며, 피연산자 중 하나가 객체라면 숫자 선호 알고리즘을 통해 기본 값으로 변환하지만, 객체를 숫자로 변환하는 경우와 달리 여기서 숫자 선호 알고리즘이 반환하는 기본 값은 숫자로 변환되지 않음


## `toString()`과 `valueOf()` 메서드
- `toString()` 은 객체의 문자열 표현을 반환하며, 대부분의 클래스에 해당 클래스에 알맞는 `toString()` 메서드가 정의되어 있음
- `ValueOf()` 는 객체를 표현하는 기본 값이 존재한다면 그 값으로 객체를 변환하지만, 대부분의 객체는 단일한 기본 값으로 표현하는 것이 불가능하여, 기본 값이 아니라 객체 자체를 반환함


## 객체에서 기본 값으로 변환하는 알고리즘

### 문자열 선호 알고리즘
- 문자열 선호 알고리즘은 먼저 `toString()` 메서드를 시도하고 정의되어 있고 기본 값을 반환한다면 그 값을 사용하고 기본 값이 문자열이 아니더라도 사용함
- `toString()` 이 존재하지 않거나 객체를 반환한다면 `valueOf()` 를 시도하고, 메서드가 존재하고 기본 값을 반환한다면 그 값을 사용하며, 그렇지 않으면 `TypeError` 가 일어남

### 숫자 선호 알고리즘
- 문자열 선호 알고리즘과 비슷하지만, `valueOf()` 를 먼저 시도하고 `toString()` 을 두 번째로 시도함

### 선호 없음 알고리즘
- 객체의 클래스에 따라 다르게 동작하며, `Date` 객체일 경우 문자열 선호 알고리즘을 사용하며, 그 외의 객체는 숫자 선호 알고리즘을 사용

---

위의 여러 알고리즘에 따라 실제로 적용해보면

```
Number([])   // => 0: 예상대로인 값
Number([99]) // => 99: 설마?
```

객체를 숫자로 변환할 때는 숫자 선호 알고리즘을 사용하여 기본 값으로 변환하고, 그 기본 값을 숫자로 변환함

숫자 선호 알고리즘은 `valueOf()` 를 시도하고 실패할 경우 `toString()` 을 시도함

하지만, 배열은 기본 `valueOf()` 메서드를 상속하는데, 이 메서드는 기본 값을 반환하지 않음

따라서 빈 배열은 빈 문자열로 변환 됨, 그리고 이 빈 문자열은 숫자 0으로 변환 됨

요소가 하나뿐인 배열은 요소가 변환되는 것과 같은 문자열로 변환되며, 요소가 숫자 하나뿐이라면 그 숫자가 먼저 문자열로 변환되고, 다시 숫자로 변환됨



# 3.10 변수 선언과 할당

프로그램은 보통 이름 또는 식별자를 값에 부여하고 프로그램에서 그 값을 참조할 수 있고, 이러한 과정을 일반적으로 변수에 값을 할당한다고 말함

변수는 새로운 값이 할당할 수 있음을 암시하고, 따라서 프로그램이 실행됨에 따라 변수에 연결된 값이 바뀔 수 있음

값에 영구히 할당할 때는 변수 대신 상수라 표현함

ES6 이후에는 `let` 과 `const` 를 사용하지만, 이전에는 `var` 를 사용했고 이 키워드는 특이한 부분이 있어 `3.10.2` 절에 설명함


# 3.10.1 let과 const를 사용한 선언
ES6 이후에 변수를 선언할 때 `let` 을 사용하며 `let` 문 하나에 변수 여러개를 선언할 수도 있음

```
let i, sum;
```

하지만, 변수를 선언할 때 초깃값을 할당하는 것이 좋은 습관

```
let message = "hello";
let i = 0, j = 0, k = 0;
let x = 2, y = x*x // 직전에 선언한 변수를 이용해 초기화도 가능
```

`let` 문에 초깃값을 할당하지 않으면 값을 할당할 때까지 `undefined` 로 남음

---

상수를 선언할 때는 `const` 를 사용하며, 선언할 때 반드시 값을 할당해 초기화 해야 함

상수의 값을 바꾸려 하면 `TypeError` 가 일어남

상수를 선언할 때는 규칙은 아니지만 전부 대문자를 사용하여 변수와 구별하는 관습이 있음

`for, for/in for/of` 루프에도 루프 변수에 보통 `let` 을 이용하여 선언하여 사용하지만, `const` 도 가능하며, 루프의 주기 안에 값이 바뀌지 않는다는 의미를 가짐


---

## 변수와 상수 스코프

`let` 과 `const` 로 선언한 변수와 상수는 블록 스코프를 가지며, 이 뜻은 해당 블록 안에서만 변수와 상수가 유효하다는 뜻

자바스크립트의 클래스와 함수 정의는 블록이고, `if/else` 문, `while` 루프, `for` 루프 등의 바디 역시 블록임

대략적으로 중괄호 안에 변수나 상수를 선언하면 그 중괄호가 변수와 상수가 정의된 영역

선언이 어떤 코드 블록에 속하지 않고 최상위 레벨에 있을 경우 전역 변수 또는 상수라고 부르면, 이들은 전역 스코프를 가짐

자바스크립트 모듈에서 전역 변수의 스코프는 해당 변수가 정의된 파일임

하지만 전통적인 클라이언트 사이드 자바스크립트에서 전역 변수의 스코프는 변수가 정의된 `HTML` 문서이며, `<script>` 에서 전역 변수나 상수를 선언하면 그 변수는 해당 문선의 `<script>` 요소 전체에 존재함


## 반복 선언
같은 스코프에서 같은 이름으로 변수나 상수를 선언하면 문법 에러

하지만, 중첩된 스코프에서 같은 이름의 변수를 선언하는 것은 가능

```
const x = 1;          // x를 전역 상수로 선언합니다.
if (x === 1) {
	let x = 2;        // 블록 안에서 다시 선언할 수 있습니다.
	console.log(x);   // 2
}  
console.log(x);       // 1: 지금은 전역 스코프에 있습니다.
let x = 3;            // 에러. X를 다시 선언하려 하는 것은 문법 에러입니다.
```


## 선언과 타입
자바스크립트는 변수 선언에서 타입을 지정하지 않음

변수는 어떤 타입의 값이든 가질 수 있으며, 변수에 숫자를 할당한 다음 다시 문자열을 할당하는 것도 가능 (좋은 프로그래밍 스타일은 아님)


# 3.10.2 var를 사용한 변수 선언
`var` 의 문법은 `let` 과 같으나 중요한 차이가 있음


- `var` 로 선언한 변수는 블록 스코프를 갖지 않으며, 얼마나 깊이 중첩됐든 관계없이 포함하는 함수 바디를 스코프로 가짐
- 함수 바디 바깥에서 `var` 를 사용하면 전역 변수로 선언되지만, `var` 로 선언된 전역 변수와 `let` 으로 선언된 전역 변수에는 차이가 있음
	- `var` 로 선언된 전역 변수는 전역 객체의 프로퍼티로 존재
	- 전역 객체는 `globalThis` 로 참조할 수 있기에 함수 바깥에서 `var x = 2;`  는 `globalThis.x = 2;` 와 같은 의미
	- 하지만, `var` 로 선언된 전역 변수는 `delete` 연산자로 삭제할 수 없음
	- `let, const` 로 선언된 전역 변수와 상수는 전역 객체의 프로퍼티가 아님
- `let` 선언과 달리 `var` 는 같은 변수를 몇 번이고 선언할 수 있음
- `var` 변수를 선언하면 호이스팅이 발생하여 이 선언문은 함수의 맨 위로 끌어올려 
- `var` 는 초기화 코드가 실행되기 전이라면 `undefined` 일 수 있지만 사용한다고 해서 에러가 발생하지는 않으나, `let` 으로 변수를 선언하면 `undefined` 값이 나타나고 실제로 에러가 일어남

---

## 선언되지 않은 변수 사용
스트릭트 모드에서는 선언되지 않은 변수를 사용하려 하면 코드 실행 시점에서 참조 에러(reference error)가 일어남

스트릭트 모드가 아니라면 `let, const, var` 로 선언하지 않은 이름에 값을 할당하려 해도 어레가 일어나지 않으며 전역 변수로 생성되고 이러한 변수는 `var` 로 선언한 전역 변수와 마찬가지로 전역 객체의 프로퍼티가 되지만, `delete` 연산자로 삭제할 수 있음


# 3.10.3 분해 할당
ES6에서 선언과 할당을 합친 복합 문법을 도입했으며 이를 분해 할당(destructuring assignment)라 부름

할당 연산자의 오른쪽에 있는 값은 배열이나 객체 같은 구조적인 값이며, 왼쪽에 있는 값은 하나 이상의 변수 이름이며 배열이나 객체 리터럴 문법을 사용

분해 할당이 일어나면 오른쪽 값에서 하나 이상의 값을 추출해서 왼쪽에 있는 변수에 할당함

```
let [x,y] = [1,2]; // let x=1, y=2와 같습니다.
[x,y] = [x+1,y+1]; //x=x+1,y=y+1과같습니다.  
[x,y] = [y,x];     // 두 변수의 값을 바꿉니다.  
[x,y]              // => [3,2]: 값을 증가시킨 후 서로 바꿨습니다.
```

---

분해 할당을 활용하여 배열을 반환하는 함수를 쉽게 사용할 수 있음

```
// [x,y] 좌표를 [r,theta] 극좌표로 변환합니다. 
function toPolar(x, y) {
	return (Math.sqrt(x*x+y*y), Math.atan2(y,x)];
}

// 극좌표를 카르테시안 좌표로 변환합니다.
function toCartesian(r, theta) {
	return [r*Math.cos(theta), r*Math.sin(theta)];
}

// r==Math.sqrt(2); theta==Math.PI/4
let [r,theta] = toPolar(1.0, 1.0);
 
// [x, y] == [1.0, 1,0]
let [x,y] = toCartesian(r,theta);
```


---

루프에서도 분해 할당을 사용할 수 있음

아래의 코드는 객체의 프로퍼티 전체의 이름-값 쌍을 순회하며 분해 할당을 통해 각 쌍을 요소가 두 개 있는 배열에서 개별 변수로 변환함

```
let o = {x: 1, y: 2}; //순회할 객체

for(const [name, value] of Object.entries(o)) { 
	console.log(name, value); // "x 1", "y 2"
}
```


---

분해 할당에서 왼쪽에 있는 변수 숫자와 오른쪽에 있는 값 숫자가 일치할 필요가 없음

왼쪽의 변수가 남으면 `undefined` 가 할당되고, 오른쪽의 값이 남으면 무시되며 왼쪽의 변수 리스트에 콤마를 추가로 넣어서 값을 일부 무시할 수도 있음

```
let [x,y] = [1];     // x == 1; y == undefined
[x,y] = [1,2,3];     // x == 1; y == 2  
[,x,,y] = [1,2,3,4]; // x == 2; y == 4
```

다음과 같이 마지막 변수 이름 앞에 점 세 개(...)를 써서 배열을 분해하고 남은 값을 변수 하나에 모을 수 있음

```
let [x, ...y] = [1,2,3,4]; // y == [2,3,4]
```

---

분해 할당은 중첩된 배열에서도 사용 가능하며, 이런 경우 왼쪽은 중첩된 배열 리터럴 형태여야 함

```
let [a, [b, c]] = [1, [2,2.5], 3]; // a == 1; b == 2; c == 2.5
```


배열 문해에 꼭 배열만 써야 되는 건 아니라, 분해 할당의 오른쪽에는 이터러블 객체면 무엇이든 사용 가능

```
let [first, ...rest] = "Hello"; // first == "H"; rest == ["e","l","l","o"]
```

---

객체도 분해 할당할 수 있으며, 이런 경우 왼쪽은 객체 리터럴처럼 중괄호 안에 변수 이름을 콤마로 구분한 형태여야 함

```
let transparent = {r: 0.0, g: 0.0, b: 0.0, a: 1.0}; // RGBA색깔
let {r, g, b} = transparent; // r == 0.0; g == 0.0; b == 0.0
```

아래의 코드는 `Math` 객체의 함수를 변수에 복사함

```
// const sin=Math.sin, cos=Math.cos, tan=Math.tan과 같습니다.
const {sin, cos, tan} = Math;
```

---

객체를 분해하는 예제에서 변수 이름은 분해하는 객체의 프로퍼티 이름과 일치하게 정했지만, 꼭 이렇게 해야 하는 것은 아니며, 왼쪽 값에 (:) 으로 구분한 식별자 쌍을 쓸 수 있음

```
// const cosine = Math.cos, tangent = Math.tan과 같습니다.
const { cos: cosine, tan: tangent } = Math;
```

---

중첩된 객체, 객체의 배열, 배열의 객체에서도 사용 가능

```
let points= [{x: 1, y: 2}, {x:3, y: 4}); //좌표 객체가 두개 있는 배열

let [{x: x1, y: y1}, {x: x2, y: y2}] = points; // 변수 네 개로 분해했습니다.

(x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // => true


let points = { p1: [1,2], p2: [3,4] }; // 배열 두 개가 있는 객체 let { p1: [x1, y1], p2: [x2, y2] } = points; // 변수 네 개로 분해했습니다. 
(x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // => true
```


# 3.11 요약

이 장에서 기억해야 하는 핵심 내용

- 숫자와 문자열을 만들고 조작하는 방법
- 불, 심벌, `null`, `undefined` 를 다루는 방법
- 불변인 기본 타입과 가변인 참조 타입의 차이
- 묵시적으로 타입을 변환하는 과정, 프로그램에서 직접 변환하는 방법
- 상수와 변수를 선언하고 초기화하는 방법(분해 할당 포함), 선언하는 변수와 상수의 어휘적 스코프
