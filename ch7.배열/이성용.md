# 7장 배열

배열은 값의 순서 있는 집합이다.

각 값을 요소라고 부르며 각 요소에는 배열에서 차지하는 위치를 나타내는 숫자인 인덱스가 있다.

자바스크립트 배열은 ‘0으로 시작’하는 32비트 인덱스를 사용한다. 첫 번째 요소의 인덱스는 0이고, 인덱스는 최대 4,294,967,294(2^32-2)까지 커질 수 있으므로 배열에 담을 수 있는 요소의 수는 최대 4,294,967,295개이다.

자바스크립트 배열은 동적이다. 필요한 만큼 커지거나 작아질 수 있고, 배열을 생성할 때 고정된 크기를 선언하거나 크기가 변할 때 배열을 재할당 할 필요가 없다. 자바스크립트는 성긴(sparse) 배열을 허용한다. 즉 요소의 인덱스가 꼭 이어질 필요는 없고 그 사이에 갭이 있어도 된다.

자바스크립트 배열에는 모두 length 프로퍼티가 있다. 성기지 않은 배열에서 이 프로퍼티는 배열에 포함된 요소 숫자이다. 성긴 배열의 length는 배열 내 가장 큰 인덱스보다 크다.

자바스크립트 실행 환경은 일반적으로 배열을 최적화하므로 숫자로 인덱스 된 배열 요소는 일반적인 객체 프로퍼티보다 상당히 빠르게 접근할 수 있다.

배열은 Array.prototype에서 프로퍼티를 상속한다.

## 배열 생성

### 배열 리터럴

```jsx
let empty = []; // 요소가 없는 배열
let primes = [2, 3, 5, 7, 11]; // 숫자 요소가 다섯 개 있는 배열
let misc = [1.1, true, "a", ]; // 타입이 다른 요소가 세 개 있고 콤마로 끝난 배열

// 상수가 아닌 임의의 표현식
let base = 1024;
let table = [base, base+1, base+2, base+3];
// 객체 리터럴이나 배열 리터럴
let b = [[1, {x: 1, y: 2}], [2, {x: 3, y: 4}]];

// 성긴 배열
let count = [1,,3]; // 인덱스 0과 2에는 요소가 있지만 인덱스 1에는 요소가 없습니다.
let undefs = [,,]; // 요소가 없지만 길이가 2인 배열
```

### 분해 연산자

```jsx
let a = [1, 2, 3];
let b = [0, ...a, 4]; // b == [0, 1, 2, 3, 4]

// 얕은 복사 (shallow)
let original = [1,2,3];
let copy = [...original];
copy[0] = 0; // 사본을 수정해도 원본에는 영향이 없습니다.
original[0] // => 1

let digits = [..."0123456789ABCDEF"];
digits // => ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]

// 이터러블 객체 (for/of 루프의 대상이 될 수 있는 객체)
let letters = [..."hello world"];
[...new Set(letters)] // => ["h","e","l","o"," ","w","r","d"]
```

### Array() 생성자

```jsx
let a = new Array(); // => []
let a = new Array(10);
let a = new Array(5, 4, 3, 2, 1, "testing, testing");
```

### Array.of()

인자의 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용한다.

```jsx
Array.of() // => []; 인자가 없으므로 빈 배열
Array.of(10) // => [10]; 숫자 인자 하나만 있어도 됩니다.
Array.of(1,2,3) // => [1, 2, 3]
```

### Array.from()

Array.from(iterable)은 분해 연산자를 사용한 [...iterable]과 동등하다.

```jsx
let copy = Array.from(original);
let truearray = Array.from(arraylike);
console.log(...['foo']); // =>
console.log(Array.from('foo')) // =>

console.log(Array.from([1, 2, 3], x => x + x)); // => [2, 4, 6]
```

## 배열 요소 읽기와 쓰기

```jsx
let a = ["world"]; // 요소가 하나 있는 배열로 시작합니다.
let value = a[0]; // 인덱스 0을 읽습니다.
a[1] = 3.14; // 인덱스 1에 씁니다.
let i = 2;
a[i] = 3; // 인덱스 2에 씁니다.
a[i + 1] = "hello"; // 인덱스 3에 씁니다.
a[a[i]] = a[0]; // 인덱스 0과 2를 읽은 다음, 인덱스 3에 씁니다.
```

2^32-1보다 작은 양의 정수인 인덱스에 값을 할당하면 그 배 열의 length 프로퍼티가 자동으로 바뀐다.

```jsx
let o = {}; // 일반적인 객체를 생성합니다.
o[1] = "one"; // 정수 인덱스를 붙입니다.
o["1"] // => "one"; 프로퍼티 이름이 숫자이든 문자열이든 똑같습니다.

const a = [1,2,3];
console.log(a["1"]);
```

자바스크립트는 숫자인 배열 인덱스를 문자열로 변환한다. 즉 인덱스 1은 문자열 “1”이 되며, 이 문자열을 프로퍼티 이름으로 사용한다.

배열 인덱스에는 음수도, 정수 아닌 숫자도 쓸 수 있다. 이렇게 하면 숫자를 문자열로 변환하고 그 문자열을 프로퍼티 이름으로 사용한다. 이런 프로퍼티는 이름이 양의 정수가 아니므로 배열 인덱스가 아니라 일반적인 객체 프로퍼티로 취급한다.

마찬가지로, 양의 정수로 평가되는 문자열을 인덱스로 사용하면 객체 프로퍼티가 아니라 배열 인덱스로 취급한다. 부동 소수점 숫자도 마찬가지다

```jsx
a[-1.23] = true; // -1.23이라는 프로퍼티가 생깁니다.
console.log(a[-1.23]); // => true
a["1000"] = 0; // 배열의 1001번째 요소입니다.
a[1.000] = 1; // 배열 인덱스 1. a[1] = 1;과 같습니다.

a[1.000] = 100;
console.log(a[1]); // => 100
```

```jsx
let a = [true, false]; // o| 배열은 인덱스 0과 1에 요소가 있습니다.
a[2] // => undefined; 이 인덱스에는 요소가 없습니다.
a[-1] // => undefined; 이런 이름의 프로퍼티는 없습니다.
```

## 성긴 배열

인덱스가 연속적이지 않은 배열

```jsx
let a = new Array(5); // 요소가 없지만 a.length는 5입니다.
a = []; // 요소가 없고 length가 0인 배열
a [1000] = 0; // 요소는 하나를 추가하지만 길이는 1001로 만드는 할당
```

```jsx
let al = [,]; // 이 배열은 요소가 없고 길이는 1입니다.
let a2 = [undefined]; // o| 배열에는 undefined 요소가 하나 있습니다.
0 in al // => false: al은 인덱스 0에 요소가 없습니다.
0 in a2 // => true: a2는 인덱스 0에 undefined 값이 있습니다.
```

## 배열 길이

```jsx
[].length // => 0: 배열에 요소가 없습니다.
["a","b","c"].length // => 3: 가장 큰 인덱스는 2이고 길이는 3입니다.
```

배열의 length 프로퍼티를 현재 값보다 작은 양의 정수 n으로 지정할 때 인덱스가 n 이상인 배 열 요소는 모두 삭제하는 동작이다.

```jsx
a = [1,2,3,4,5]; // 요소가 다섯 개 있는 배열로 시작합니다.
a.length = 3 // a는 이제 [1,2,3]입니다.
a.length = 0 // 요소 전체를 삭제합니다. a는 []입니다.
a.length = 5 // 길이는 5이지만 new Array(5)와 마찬가지로 요소는 없습니다.
```

## 배열 요소 추가와 삭제

```jsx
let a = []; // 빈 배열로 시작합니다.
a[0] = "zero"; // 요소를 추가합니다.
a[1] = "one";

let a = []; // 빈 배열로 시작합니다.
a.push("zero"); // 마지막에 값을 추가합니다. a = ["zero"]
a.push("one", "two"); // 값을 두 개 더 추가합니다. a = ["zero", "one", "two"]
```

push()는 a[a.length]에 값을 할당하는 것과 같다.

```jsx
let a = [1,2,3];
delete a[2]; // a는 이제 인덱스 2에 요소가 없습니다.
2 in a // => false: 배열 인덱스 2는 정의되지 않았습니다.
a.length // => 3: delete는 배열 길이에 영향을 주지 않습니다.

let a = [1, 2, 3];
delete a[1];
a.forEach(n => console.log(n)) // => 1 3

let b = [1, 2, 3];
b[1] = undefined;
b.forEach(n => console.log(n)) // => 1 undefined 3
```

배열 요소를 삭제하는 것은 그 요소에 undefined를 할당하는 것과 비슷하다.

## 배열 순회

**for/of**

```jsx
let letters = [..."Hello world"]; // 글자로 이루어진 배열 let string =
for(let letter of letters) {
	string += letter;
}
string // => "Hello world"; 원래 텍스트를 다시 만들었습니다.

let everyother = "";
for(let [index, letter] of letters.entries()) {
	if (index % 2 === 0) everyother += letter; // 짝수 번째 인덱스의 글자
}
everyother // => "Hlowrd"
```

**forEach()**

```jsx
let uppercase = "";
letters.forEach(letter => { // 화살표 함수 문법을 썼습니다.
	uppercase += letter.toUpperCase();
});
uppercase // => "HELLO WORLD"
```

for/of 루프와 달리 forEach()는 성긴 배열을 인식하고 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.

**for**

```jsx
let vowels = "";
for(let i = 0; i < letters.length; i++) { // 배열의 각 인덱스에 대해
	let letter = letters[i]; // 해당 인덱스의 요소를 가져옵니다.
	if (/[aeiou]/.test(letter)) { // 정규 표현식을 써서
		vowels += letter; // 모음이라면 병합 할당합니다.
	}
}
vowels // => "eoo"

for(let i = 0; i < a.length; i++) {
if (a[i] === undefined) continue; // 유효하지 않은 요소는 건너뜁니다. // 루프 바디
}
```

중첩된 루프나 기타 성능이 아주 중요한 상황에서는 배열 길이를 단 한 번만 계산하도록 만들기도 한다. 두 for 루프는 그리 널리 쓰이지는 않으며 최신 자바스크립트 인터프리터 에서는 성능 차이도 거의 없다.

```jsx
// 배열 길이를 로컬 변수에 저장합니다.
for(let i = 0, len = letters.length; i < len; i++) {
	// 루프 바디는 마찬가지입니다.
}

// 배열의 마지막에서 시작해 역순으로 순회합니다.
for(let i = letters.length - 1; i >= 0; i--) {
	// 루프 바디는 마찬가지입니다.
}
```

```jsx
for(let i = 0; i < a.length; i++) {
	if (a[i] === undefined) continue; // 유효하지 않은 요소는 건너뜁니다.
	// 루프 바디
}
```

## 다차원 배열

## 배열 메서드

### 배열 이터레이터 메서드

### flat()와 flatMap()을 사용한 배열 평탄화

### concat()으로 배열 병합

### 스택과 큐 메서드

### 하위 배열

### 배열 검색과 정렬 메서드

### 배열을 문자열로 변환

### 정적 배열 함수

## 배열 비슷한 객체

## 배열인 문자열