# 7장 배열

배열은 값의 순서 있는 집합이며, 각 값을 요소라 부르고 각 요소에는 배열에서 차지하는 위치를 나타내느 숫자인 인덱스가 있음

인덱스는 0으로 시작하는 32비트 인덱스를 사용

`0 ~ 4,294,967,294(22-2)` 까지 사용 가능함

자바스크립트 배열을 동적이고, 성긴(sparse) 배열을 허용함
-> 인덱스가 꼭 이어질 필요 없고, 사이에 갭이 있어도 됨

성긴 배열에서 배열의 `length` 는 배열 내 가장 큰 인덱스 보다 큼

자바스크립트 배열은 객체의 특별한 형태이며 프로퍼티 이름이 정수인 것과 별로 다르지 않으나 실행 환경에서 일반적으로 배열을 최적화함

`ES6` 에서 형식화 배열(typed arrray) 라는 새로운 배열 클래스를 몇 가지 도입함
-> 길이가 고정적이며, 요소 타입도 숫자로 고정되어 있으며 아주 빠르고 이진 데이터에 바이트 수준으로 접근 가능(11.2절에서 설명)

# 7.1 배열 생성

## 7.1.1 배열 리터럴

`let empty = []` 형태로 만들 수 있으며, 배열 리터럴에 상수가 아닌 표현식도 가능

배열 리터럴에 콤마를 연속으로 사용했는데 그 사이에 값이 없으면 성긴 배열이 만들어짐
-> 값을 생략한 위치에 실제로 배열 요소가 존재하지 않지만 검색하면 `undefined` 가 반환됨

`let undefs = [,,]; // 요소가 없지만 길이가 2인 배열`

배열 리터럴은 마지막에 콤마를 허용하므로 `[,,]` 의 길이는 3이 아니라 2임


## 7.1.2 분해 연산자

`ES6` 의 `...` 분해 연산자를 사용하여 배열 리터럴 안에 다른 배열 요소를 넣을 수 있음

```
let a = [1, 2, 3];
let b = [0, ...a, 4]; // b == [0, 1 ,2, 3, 4]
```


shallow copy에도 사용

첨언) primitive type 만 있는 배열이라면 deep copy 처럼 활용됨 (이유는 모름)



분해 연산자는 또한 이터러블 객체에 사용가능함



## 7.1.3 Array() 생성자

`new Array()` 같이 인자없이 호출하거나 

`new Array(10)` 같이 배열의 길이를 추가해 호출 할 수도 있음, 배열 값, 인덱스는 정의되지 않음

`new Array(5, 4, 3, 2, 1)` 같이 두 개 이상 인자를 넘기면 배열의 요소가 추가되면 생성됨





## 7.1.4 Array.of()

`Array.of()` 는 `ES6` 에서 나온 함수로 빈 배열이나 요소가 하나만 있는 배열을 만들 수 없는 경우에도 사용 가능

```
Array.of() // => []
Array.of(10) // => [10]
Array.of(1,2,3) // => [1,2,3]
```


## 7.1.5 Array.from()

`Array.from()` 도 `ES6` 에서 도입한 팩토리 메서드이며 이터러블 객체나 배열 비슷한 객체를 받음

`[...array]`  와 동등함

`length` 프로퍼티가 있고 이름이 정수인 프로퍼티에 값이 저장된 객체를 배열로 변경할 수 있음, 웹 브라우저 메서드가 일부 이러한 배열 비슷한 객체를 반환함

두 번째 인자에 함수를 전달하면 각 요소를 함수에 전달하고 반호나 값을 배열에 저장함, `map()` 과 비슷하지만 생성시 부터 처리하는 것이 효율적



# 7.2 배열 요소 읽기와 쓰기

배열 참조값 오른쪽에 `[]` 연산자를 사용하여 접근 가능

`2^32 - 1`  보다 작은 양의 정수인 인덱스 값을 할당하면 그 배열의 `length` 프로퍼티가 자동으로 바뀜

양의 정수로 평가되는 문자열은 숫자로 변환하여 사용되지만 `0 ~ 2^23 -2` 이외의 범위에 숫자는 해당 프로퍼티가 생성됨

```
a[-1.23] = true; // -1.23 이라는 프로퍼티가 생김
a["1000"] = 0; // 배열의 1001 번째 요소
a[1.000] = 1; // 배열 인덱스의 1, a[1] = 1; 과 동일
```


배열 인덱스는 특별한 타입의 객체 프로퍼티 이름일 뿐이므로 경계 초과 (out of bounds) 에러가 일어나지 않음, `undefined` 를 반환할 뿐



# 7.3 성긴 배열


인덱스가 연속적이지 않은 배열

일반적으로 `length` 가 배열의 값의 요소 개수보다 큼

```
let a = new Array(5);
a = [];
a[1000] = 0; // 요소는 하나를 추가하지만 길이는 1001로 만드는 할당
```

메모리를 효율적으로 사용하는 방법으로 구현되며, 요소를 검색하는 시간은 일반적인 객체 프로퍼티 검색에 필요한 시간과 비슷

`[1,,3]` 과 같이 배열 리터럴에 콤마를 반복하면 성긴 배열이 생성됨, 생략된 요소는 존재하지 않음

```
let a1 = [,]; 
let a2 = [undefined];
0 in a1 // => false: a1은 인덱스 0에 요소가 없음
0 in a2 // => true: a2는 인덱스 0에 undefined 값이 있음
```



# 7.4 배열 길이

배열의 `length` 보다 크거나 같은 인덱스는 존재하지 않음

이를 위해 배열의 `i` 인덱스 값을 할당할 때 `length` 프로퍼티를 `i + 1` 로 갱신함

또한, `length` 프로퍼티를 현재 값보다 작은 양의 정수 `n` 으로 지정할 때 인덱스가 `n` 이상인 배열 요소는 모두 삭제함

# 7.5 배열 요소 추가와 삭제

인덱스에 요소를 추가하거나 `push()` 메서드로 배열 마지막에 값을 추가함

배열 요소를 삭제하면 그 요소에 `undefined` 를 할당하는 것과 비슷 (완전 같지는 않음)

배열 요소에 `delete` 를 사용하더라도 `length` 프로퍼티는 변하지 않으며, 빈 공간을 매우기 위해 요소가 이동하지도 않음



# 7.6 배열 순회

`for/of` 루프락 배열을 순회하기 좋음

`for/of` 루프가 사용하는 내장 이터레이터는 오름차순으로 요소를 반환하며, 존재하지 않은 배열 요소에 대해서는 `undefined` 를 반환함

`forEach()` 도 배열을 순회하며 `for` 를 변형한 것이 아니라 함수형으로 바꾼 배열 메서드임

`for/of` 루프와 달리 `forEach()` 는 성긴 배열을 인식하고 존재하지 않는 요소에 대해서는 함수를 호출하지 않음



# 7.7 다차원 배열
배열안에 배열을 만들 수 있으며 접근하는 경우 차원의 개수 만큼 `[]` 을 사용해 접근하면됨

`table[5][7]` 과 같은 형태


# 7.8 배열 메서드

## 7.8.1 배열 이터레이터 메서드

모두 첫 번째 인자로 함수르 받으며 각 배열 요소에 대해 그 함수를 한 번씩 호출함

성긴 배열이라면 호출하지 않음

모두 원래 배열을 수정하지 않음 (전달하는 함수가 원래 배열을 수정할 수는 있음)


### forEach()

배열을 순회하며 각 요소에서 함수를 호출함

모든 요소를 함수에 전달하기 전에 멈출 수 없어 `break` 와 같이 멈추는 수단이 없음


### map()

각 배열 요소를 함수에 전달해 호출하며 그 함수가 반환한 값으로 이루어진 배열을 반환함


### filter()

각 배열요소에 전달하는 함수를 통해 결과 값을 `true/false` 로 받으며 `true, true로 변환 될 수 있는 값` 이면 반환되는 배열에 포함 됨

### find() findIndex()

전달하는 함수에서 `true` 로 반환하는 요소를 찾고 첫 번째 요소를 찾는 즉시 순회를 멈추고 반환하며, `find()` 는 해당 요소를 `findIndex()` 는 요소의 인덱스를 반환함

찾지 못한다면 `find()` 는 `undefined` 를 `findIndex()` 는 `-1` 을 반환함



### every() some()

배열 요소에 판별 함수를 적용하고 결과에 따라 `true/false` 를 반환함

`every()` 는 모든 요소에 대해 `true` 인 경우 `true` 를 반환함

`some()` 은 `true` 를 반환하는 값이 하나라도 있으면 `true` 를 반환하고 전체가 `false` 인 경우에 `false` 를 반환함

두 함수 모두 어떤 값을 반환할 지 확실해질 때 순회를 멈춤

수학적인 관습에 따라 빈 배열에 대해 `every()` 는 `true` 를 `some()` 은 `false` 를 반환함



### reduce() reduceRight()


베열의 값을 축소하는 함수들로 두 번째 인자는 선택사항으로 초깃값임

첫 번째 인자는 축소 과정이 일어나는 작업 결과이며 첫 호출시에는 행한 작업이 없으니 초깃값을 사용함

빈 배열에 초깃값 없이 `reduce()` 를 호출하면 `TypeError` 가 일어남

`reduceRight()` 은 `reduce()` 와 마찬가지지만 오른쪽에서 왼쪽으로 진행됨

## 7.8.2 flat()과 flatMap()을 사용한 배열 평탄화

`ES2019` 에서 도입한 `flat()` 은 평탄한 새 배열은 반환함

```
[1, [2,3]].flat() // => [1,2,3]
[1, [2, [3]]].flat() // => [1,2,[3]]
```

인자 없이 `flat()` 을 호출하면 한 단계만 평탄화 함, 인자에 값을 전달하면 해당 값만큼 평탄화 레벨을 진행함


`flatMap()` 메서드는 `map()` 메서드와 같이 동작하지만 반환값이 `flat()` 처럼 자동으로 평탄화됨

## 7.8.3 concat()으로 배열 병합

기존 배열 요소를 포함하고 그 뒤에 `concat()` 의 인자를 포함하는 새로운 배열을 만들어 반환함

인자에 배열이 들어 있으면 배열이 아니라 요소를 추가하지만, 중첩된 배열은 평탄화 시키지 않음

기존 배열을 수정하지 않음


## 7.8.4 스택과 큐 메서드


두 메서드 모두 기존 배열을 수정하며 `push()` 는 배열의 끝에 하나 이상의 새요소를 추가 `pop()` 은 제거함

`push()` 메서는 전달한 배열을 평탄화 하지 않음, 분해 연산자를 통해 평탄화 할 수 있음

`a.push(...values)`

`unshift(), shift()` 는 위 두 메서드와 비슷하지만 배열의 앞부분에서 이루어짐

`unshift()` 는 인자 여러개를 전달하면 모두 한번에 삽입되므로 한번에 하나씩 삽입했을 때와 결과가 다름

```
a.unshift(1)
a.unshift(2)

// => a == [2,1]

b.unshift(1,2)

// => b == [1,2]

```

## 7.8.5 하위 배열

### slice()

두 개의 인자로 시작과 끝 위치를 받으며 시작부터 끝의 바로 앞까지 추출하여 배열을 복사함, 원본 배열은 변하지 않음


### splice()

배열의 요소를 삽입, 삭제 하는 메서드

배열의 원래 요소를 수정함

첫 번째 인자는 삽입/제거를 시작할 위치, 두 번째 인자는 제거할 요소의 개수

두 번째 이후부터의 인자는 첫 번째 인자에서 지정한 위치에서부터 배열에 삽입됨

`concat()` 과 달리 평탄화하여 삽입하지 않음


### fill()

첫 번째 인자는 배열 요소로 사용할 값이며, 두 번째 인자는 선택사항이며 시작할 인덱스, 생략한다면 인덱스 0에서 시작

```
let a = new Array(5);
a.fill(0) // => [0,0,0,0,0]
a.fill(9,1) // => [0,9,9,9,9]
a.fill(8,2,-1) // => [0,9,8,8,9]
```

선택 사항인 세 번째 인자는 마지막 인덱스이며 바로 앞까지 작업함, 세 번째 인자가 없다면 마지막 까지 진행

### copyWithin()

배열의 슬라이스를 복사해 새 위치에 붙여 넣음

첫 번째 요소는 복사될 위치의 인덱스, 두 번째 인자는 복사할 첫 번째 요소의 인덱스, 세 번째 인자는 복사할 슬라이스의 끝 (생략시 배열 길이를 사용) , 다른 메서드와 마찬가지로 마지막 인덱스 바로 앞까지 복사함



```
let a = [1,2,3,4,5];

a.copyWithin(1) // => [1,1,2,3,4] : 전체를 복사해 인덱스 1에 덮어 씁니다.
a.copywithin(2, 3, 5) // => [1,1,3,4,4]: 마지막 두 개를 복사해 인덱스 2에 덮어 씁니다.
a.copyWithin(0, -2) // => [4,4,3,4,4]: 음수도 잘 동작합니다.
```

형식화 배열에 유용

`c` 라이브러리의 `memmove()` 함수를 모델로 만들어졌음, 원본과 대상 영역에 겹치는 부분이 있더라도 복사는 정확히 작동함

## 7.8.6 배열 검색과 정렬 메서드

### indexOf() 와 lastIndexOf()

지정된 값을 배열에서 찾아 해당 요소의 인덱스를 반환하며, 찾지 못하면 `-1` 을 반환함

`indexOf()` 는 배열 앞에부터 검색하고, `lastIndexOf()` 는 배열의 뒤에서부터 역순으로 검색함

배열 요소를 비교시 `===` 연산자를 사용함, 기본 값이 아니라 객체가 들어 있다면 두 참조가 정확히 같은지 참조를 확인함

객체 콘텐츠를 검색하는 목적으로는 `find()` 메서드와 판별 함수를 사용할 것

두 버째 인자에는 음수를 사용가능하며 `-1` 인 경우 마지막 배열 요소를 지정함


문자열에서도 메서드들이 작동하지만, 두 번째 인자가 음수이면 `0` 으로 취급함


### includes()

`ES2016` 에서 도입한 메서드

인자 하나를 받고 배열에 그 값이 포함되어 있으면 `true` 없다면 `false` 를 반환함

`indexOf()` 는 `NaN` 을 찾지 못하지만 `includes()` 는 찾을 수 있음

### sort()

배열 요소를 정렬함

인자 없이 호출한다면 알파벳 순으로 정렬


알파벳이 아닌 다른 순서로 배열을 정렬하고 싶다면 비교 함수를 전달해야 함

첫 번째 인자가 두 번째 인자보다 앞에 있어야 한다면 `0` 보다 작은 숫자를 반환해야 함, 동등하다면 `0` 반대라면 `0` 보다 큰 숫자를 반환해야 함

```
let a = [33, 4, 1111, 222];
a.sort(function(a,b) { // 비교 함수를 전달합니다.  
  return a-b; //순서에따라<0, 0, or>0인값을반환합니다.
} // a == [4, 33, 222, 1111]; 숫자 순서 
a.sort((a,b)=>b-a); // a==[1111,222,33,4];숫자순서의역순
```

`toLowerCase()` 메서드를 사용해 대소문자를 구분하지 않고 알파벳순으로 정렬 가능

```
let a = ["ant", "Bug", "cat", "Dog"];  
a.sort(); // a == ["Bug","Dog","ant","cat"]; 대소문자를 구별한 정렬 a.sort(function(s,t) {
  let a = s.toLowerCase();
  let b = t.toLowerCase();
  if(a < b) return -1;
  if(a > b) return 1;
  return 0;
}); // a == ["ant","Bug","cat","Dog"]; 대소문자를 구분하지 않고 정렬
```


### reverse()


배열의 요소를 거꾸로 뒤집어 반환함, 새 배열을 만들지 않고 기존 배열의 요소 순서를 뒤집음


## 7.8.7 배열을 문자열로 변환


로그나 에러 메시지를 만들 때 주로 사용

나중에 재사용할 목적으로 사용한다면 `JSON.stringify()` 를 사용할 것

`join()` 으로 배열 요소 전체를 문자열로 변환하여 병합할 수 있고, 인자를 넣는다면 요소를 구분하는 문자열을 선택할 수 있음

배열 자체의 `toString()` 을 사용한다면 `join()` 을 인자 없이 호출하는 것과 동등함




## 7.8.8 정적 배열 함수


`Array.isArray()` 는 값이 배열이지 확인할 때 유용함

# 7.9 배열 비슷한 객체

배열은 다른 객체에는 없는 특별한 기능이 있음

- 배열에 새 요소를 추가할 때마다 Length 프로퍼티가 자동으로 업데이트됩니다.
- length를 더 작은 값으로 변경하면 배열 요소를 그에 맞게 버립니다
- 배열은 Array.prototype에서 유용한 메서드를 상속합니다. 
- Array.isArray()는 배열을 받으면 true를 반환합니다.


이러한 특징들이 있지만 핵심은 아니며, 숫자인 `length` 프로퍼티가 있고 음이 아닌 정수 프로퍼티가 있는 객체라면 일종의 배열로 간주해도 문제 없음


`document.querySelectorAll()` 처럼 배열 비슷한 객체를 반환하는 메서드들이 존재함


배열 비슷한 객체는 `Array.prototype` 을 상속하지 않으므로 배열 메서드를 직접 호출할 수는 없지마, `Function.call` 메서드를 통해 간접적으로 호출할 수 있음

```
let a = {"0":"a","1":"b","2":"c",length:3}; //배열비슷한객체 Array.prototype.join.call(a, "+") // => "a+b+c"
```

# 7.10 배열인 문자열

자바스크립트 문자열은 `UTF-16` 유니코드 문자로 구성된 읽기 전용 배열처럼 동작함

`charAt()` 메서드 대신 대괄호로 개별 문자에 접근할 수 있음

# 7.11 요약

성긴 배열, 배열 비슷한 객체에 대해 설명했음

요약하자면

-  배열 리터럴은 대괄호 안에 값을 콤마로 구분해서 쓴 리스트입니다.  
-  개별 배열 요소에 접근하려면 대괄호 안에 배열 인덱스를 씁니다.
- for/of 루프와 분해 연산자 ...는 ES6에서 도입했으며 배열을 순회할 때 특히 유용한 방법입니다.
- Array 클래스에는 배열을 조작하는 메서드가 풍부합니다. 배열 API는 꼭 익숙하게 사용할 수 있어야 합니다.

