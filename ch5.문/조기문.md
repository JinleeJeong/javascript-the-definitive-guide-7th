# 5장 문

- 표현식은 평가를 통해 값으로 바뀜
- 문은 실행을 통해 어떤 동작을 수행
- 할당이나 함수 호출 처럼 부수 효과가 있는 표현식은 그 자체로 문이 될 수 있음 
→ 표현문
- 변수를 선언하거나 함수를 정의하는 선언문
- JS는 실행할 문의 모음에 지나지 않음

## 5.1 표현문

- JS에서 가장 단순한 문은 부수 효과가 있는표현식
- 할당문, delete 연산자, 함수 호출
- 함수 호출은 표현식이지만 프로그램의 상태나 호스트 환경에 영향을 미치는 부수 효과가 있음(문)
- 함수에 부수 효과가 없다면 더 큰 표현식이나 할당문의 일부가 아닌 한 호출할 의미가 없음

## 5.2 복합문과 빈 문

- 표현식 여러 개를 하나로 묶는 콤마 연산자와 마찬가지로 
→ 문 블록은 문 여러 개를 묶어 복합문으로 만든다.
- 표현식이 하위 표현식으로 구성될 수 있듯 
→ 문 역시 하위 문으로 구성될 수 있음
- JS는 공식적으로 단일 하위 문을 허용
→ ex) while 루프 문법은 루프 바디로 기능하는 단일한 문만 허용, 문 블록을 이용해 하위 문 하나에 여러 개의 문을 넣을 수 있음
- 빈문은 세미 콜론 하나로 만들 수 있음 `;`
- JS 인터프리터는 빈 문을 실행 할 때 아무 일도 하지 않음
- 빈 문은 빈 바디를 갖는 루프를 만들고자 할 때 유용

```jsx
for(let i = 0; i < a.length; a[i++] = 0);
```

## 5.3 조건문

- 분기점
- 두 개 이상의 경로로 갈라지는 분기점이며 인터프리터는 반드시 그 경로 중 하나를 선택해야 한다

### 5.3.1 if

```jsx
if (expression)
  statement
```

- expression을 평가 → true이면 state 실행

```jsx
if (exp1)
	statement1
  if(exp2)
	  statement2
else (exp3)
  statement3
```

- 내부의 if문은 외부의 if문에 속하는 것 이므로 문 하나가 되어야 한다
- JS는 기본적으로 else절을 가장 가까운 if문의 일부로 해석
→ 그래서 의도한 것 처럼 동작하게 하려면 중괄호를 사용
- if-else 문의 바디를 중괄호로 감싸는 습관을 갖고 있는 사람이 많음
- 이런 습관을 유지하면 문제를 피할 수 있음

### 5.3.2 else if

- JS문이 아니지만 if/else 문을 반복해서 사용해야 할 때 흔이 쓰는 관용적인 표현

### 5.3.3 switch

- switch 내부의 조건은 `===` 연산자를 기준으로 판단
- 일치하는 값을 찾을 때 까지 case 표현식을 순서대로 평가
- case를 찾지 못하면 default 라벨을 찾는다
- default 라벨 조차 없으면 switch 코드 블록 전체를 건너뛴다
- switch 문을 실행 할 때마다 case 표현식 전체가 평가되는 것은 아니므로
→ case 표현식에는 함수 호출이나 할당처럼 부수 효과가 있는 것은 피해야 한다
- JS에서 case 표현식은 런타임에 평가되므로 컴파일 시점에서 같은 타입의 상수여야하고, 효율적인 점프 테이블로 사용하는 다른 언어와는 달리 비효율적

## 5.4 반복문

- JS는 인터프리터가 소스 코드를 따라 분기하는 경로를 따라간다
- 반복문은 경로를 자기 자신 쪽으로 구부려 코드 일부를 반복하는 문이며 → 루프라고 한다.

### 5.4.1 while

- 인터프리터는 expression이 true 같은 값인 동안 statement를 반복적으로 실행
- 거의 모든 경우에 루프를 반복 할 때 마다 하나 이상의 변수가 변한다.
- 변수가 바뀌므로 statement를 실행하는 구체적인 동작이 매번 바뀔 수 있음
- 바뀌는 변수가 expression에 포함되어 있다면 
→ 그 표현식의 값 역시 루프를 반복 할 때마다 바뀜
- 그렇지 않다면 시작한 표현식이 절대 바뀌지 않아 무한 루프가 될 수 있음

### 5.4.2 do/while

```tsx
do
	statement
while(expression) 
```

- while 루프랑 비슷하지만 루프 표현식이 맨 위가 아니라 맨 아래서 평가
- 루프 바디는 항상 최소 한 번은 실행된다
- 루프의 시작을 알리는 do와 루프의 끝을 알리는 while 키워드가 모두 있음
- 이 루프는 항상 세미콜론으로 끝나야 한다.

### 5.4.3 for

```tsx
for (초기화 ; 테스트; 증가)
	statement
```

- 첫 행에 초기화, 테스트, 증가를 모음으로써 for 루프가 무엇을 하는지 이해하기 쉽고, 
루프 변수의 초기화나 증가를 잊는 실수를 방지
- test 표현식은 매 반복 전에 평가되고, 루프 바디를 실행할지 결정
- 초기화, 테스트, 증가 중 빠져도 되긴 하지만 세미콜론은 가지고 있어야 한다.
`for (;;)` → 무한루프

### 5.4.4 for/of

- 이터러블 객체에서 동작
- 배열, 문자열, 세트, 맵
- 반복 중간에 배열 자체에 변화가 발생한다면 반복 결과가 바뀌기도 한다 
→ 배열을 동적으로 순회
push 와 같은 것으로 다른 결과가 발생 할 수 있음

[for/of와 객체]

- 객체는 기본적으로 이터러블이 아니다
- 그래서 for/of를 사용하면 TypeError가 일어난다
- 객체의 프로퍼티를 순회하고 싶다면 `for/in`, `Object.keys() 메서드의 for/of`
- 객체의 키를 순회하는 것은 동적이지 않음 
→ 루프 바디 안에서 객체를 변경해도 결과가 달라지지 않는다

[for/of와 문자]

- utf-16 문자가 아니라 유니코드 코드 포인트로 순회
- 그래서 “이모지1이모지2” 의 length는 4
- 하지만 for/of로 순회하면 루프 바디는 코드 포인트에 대해 한번씩 총 두번 실행

[for/await를 사용한 비동기 순회]

```tsx
async function printStream(stream) {
	for await (let chunk of stream) {
		console.log(chunk)
	}
}
```

- 비동기 이터레이터와 함께 동작하도록 for/await 루프

### 5.4.5 for/in

- in 다음에 어떤 객체든 쓸 수 있다 (이터러블이 아니어도 가능)
- 조건이 맞으면 인터프리터는 객체의 열거 가능한(enumerable) 프로퍼티 각각에 한번씩 루프 바디를 실행
- 각 반복에 앞서 인터프리터는 variable을 평가하고 → 그 변수에 프로퍼티 이름을 할당
- 이 표현식은 루프를 반복 할 때 마다 평가되므로 배번 다른 값이 될 수도 있다
→ 그래서 객체 프로퍼티 이름을 배열에 복사 할 수 있다

```tsx
let o = {x: 1, y:2}
let a = [], i = 0
for (a[i++] in o) {}

a // ['x', 'y']
```

- for/in 루프의 바디에서 아직 열거되지 않은 프로퍼티를 삭제한다면 
→ 그 프로퍼티는 순회 대상에서 빠짐
- 만약 배열을 대상으로 작업한다면 거의 항상 for/of가 좋음 → 아래의 이유로

[for/in 단점]

- 실제로 객체의 프로퍼티 전체를 열거하지 않음
- 우선 이름이 심벌인 프로퍼티는 열거하지 않음
- 이름이 문자열인 프로퍼티 중에서도 열거 가능한 프로퍼티만 순회
    
    → JS에서 정의하는 내장 메서드는 열거가능하지 않음
    
- 모든 객체에 toString 메서드가 있지만 for/in 루프는 toString 프로퍼티를 열거 대상으로 간주하지 않음

이러한 단점으로 많은 프로그래머가 for/in 루프 대신 Object.keys() 와 for/of 루프를 조합하길 선호

## 5.5 점프문

- break, continue, return, yield, throw

### 5.5.1 라벨 붙은 문

- 어떤 문이든 그 앞에 다음과 같이 식별자와 콜론을 붙여서 라벨을 만들 수 있음

```tsx
mainloop: while(){
	continue mainloop // 이 루프의 다음 반복으로 점프
}
```

- 유요한 JS 식별자라면 예약어를 제외하고 무엇이든 라벨 식별자로 사용 가능
- 라벨의 네임스페이스는 변수나 함수의 네임스페이스와는 달라
→ 같은 식별자를 문 라벨에 쓰고, 다시 변수와 함수의 이름에 쓸 수도 있음
- 문 라벨이 정의되는 영역은 해당 라벨이 적용되는 문뿐

### 5.5.2 break

- break문에 라벨을 사용해서 탈출하는 경우 
→ 문이 가장 가까운 루프나 switch문이 아닐 때 탈출 가능
- break문은 라벨 여부와 관계없이 함수 바깥으로 제어권을 넘길 수 없음
→ 스트릭트 모드에서는 함수 정의에 라벨을 붙일 수 없고, 스트릭트 모드가 아니더라도
 **break문은 함수 정의에 붙은 라벨을 볼 수 없기 때문**

### 5.5.3 continue

- continue 문이 while과 for 루프에서 다르게 동작
- while에서는 조건으로 바로 넘어가지만, 
→ for 루프에서는 먼저 increment 표현식을 평가한 다음 조건으로 넘어간다

### 5.5.4 return

- 함수 호출은 표현식이고 → 표현식은 모두 값이 있다.

### 5.5.5 yield

- return 과 비슷하지만 실제로 제어권을 넘기지 않고 다음 값만 넘길 때 사용

### 5.5.6 throw

- try/catch/finally 문에서 캐치
- JS 인터프리터는 에러를 일으킬 때 Error 클래스와 그 서브클래스를 사용
- Error 객체는 에러 타입을 나타내는 `name 프로퍼티`, `생성자 함수에 전달될 문자열을 담은 message 프로퍼티`  가 있음
- 예외가 일어나면 JS 인터프리터는 즉시 프로그램 실행을 멈추고 가장 가까운 예외 핸들러로 점프

## 5.6 기타 문

### 5.6.1 with

```tsx
with(object)
	statement
```

- 지정된 객체의 프로퍼티가 해당 블록의 스코프 안에 있는 변수인 것 처럼 코드블록을 실행
- 이 문은 객체의 프로퍼티를 사용해 임시 스코프를 만들고 
→ 그 스코프 안에서 statement를 실행

```tsx
with(document.forms[0]){
	name.value = '';
	address.value = ''
}

const f = docuemnt.forms[0]
f.name.value = ''
```

- with문을 사용하는 이유는 깊이 중첩된 객체 계층 구조에서 타이핑을 줄이기 위함인데 
→ 아래와 같이하는 것도 똑같이 간단함
- 스트릭트 모드에서는 사용 할 수 없고, 최적화하기 어렵고, 느리게 동작
→ 쓰지말자

### 5.6.2 debugger

- 일반적으로 아무것도 하지 않지만
→ 디버거 프로그램이 존재하고 실행중이라면 실행 환경에 따라서는 일종의 디버깅 동작 수행
- 중단점 기능을 해서 JS 코드 실행을 멈춤
- 그러면 디버거에서 값을 출력하거나 콜 스택을 살펴 볼 수 있음

```tsx
function f(o){
	if(o === undefined) debugger
}
```

- f 함수에 정의되지 않은 인자를 넘겨서 예외가 일어났는데 어디에서 호출했는지 알 수 없다고 했을 떄 디버깅이 조금 쉬워짐

### 5.6.3 use strict

- ES5에서 도입한 지시자(directive)
- 문은 아니지만 문과 가까움
- 지시자는 아무런 키워드가 없음. 지시자는 특별한 문자열 리터럴로 구성된 표현문
- 이 지시자는 스크립트나 함수 바디의 맨 처음에만 존재 할 수 있고, 이 앞에 실제 문이 있어서는 안 된다
- 모듈로 작성한 JS 코드는 자동으로 스트릭트 모드

1. with 허용하지 않음
2. 모든 변수를 선언해야 한다
3. 메서드가 아니라 함수로 호출된 함수의 this값은 undefined(전역객체X)
4. readonly 프로퍼티에 할당하려 하거나 확장 불가능한 객체에 새 프로퍼티를 생성하면 TypeError
5. eval에 전달된 코드는 호출자의 스코프에 변수를 선언하거나 함수 정의 불가능 
6. arguments 객체는 함수에 전달된 값을 정적으로 복사해 유지
7. delete 연산자 뒤에 유효하지 않은 식별자를 쓰면 SyntaxError
8. 변경 불가인 프로퍼티를 삭제하려면 TypeError
9. 객체 리터럴을 써서 두개 이상의 프로퍼티를 같은 이름으로 정의하려면 SyntaxError
10. eval과 arguments 식별자가 키워드로 취급되며 그 값을 바꿀 수 없음
11. 콜스택을 살펴보는 기능 제한 arguments.caller, arguments.callee TypeError

## 5.7 선언

- const, let, var, function, calss, import, export
- 엄밀히 말하면 문이 아님  → 선언이 더욱 중요

### 5.7.2 함수

- 함수 선언은 함수 객체를 생성하고 이를 지정된 이름(함수 이름)에 할당
- 함수 선언은 어떤 블록에 있뜬 해당 블록의 코드보다 먼저 처리 
→ 함수 이름은 그 블록을 통틀어 함수 객체에 묶임

### 5.7.3 클래스

- 함수와 달리 클래스 선언은 끌어올려지지 않으며, 선언 하기 이전 코드에서는 사용 할 수 없음

### 5.7.4 import, export

- 다른 모듈에서 정의한 값을 사용 할 수 있게 해줌
- 모듈: JS 코드로 구성된 파일이며 독자적인 네임스페이스를 갖고, 다른 모듈에 완전히 독립적
-
