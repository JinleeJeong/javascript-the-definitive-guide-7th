# 5장 문

표현식은 ‘평가’를 통해 값으로 바뀌지만, 문은 ‘실행’을 통해 어떤 동작을 수행한다.

## 표현문(expression statement)

자바스크립트에서 가장 단순한 문, 할당이나 함수 호출처럼 부수 효과가 있는 표현식

```jsx
greeting = "Hello " + name;
i *= 3;
counter++;
delete o.x;
console.log(debugMessage);
displaySpinner();
Math.cos(x);
ex = Math.cos(x);
```

## 복합문과 빈 문

**복합문**

표현식 여러 개를 하나로 묶는 콤마 연산자와 마찬가지로 문 블록은 문 여러 개를 묶어 복합문으로 만든다.

문 블록은 그저 문 여러 개를 중괄호로 묶은 것이다. 따라서 다음 코드는 **문이 하나인 것처럼 동작**하며, 자바스크립트에서 문 하나를 예상하는 곳이라면 어디든 쓸 수 있다.

```jsx
{
	x = Math.PI;
	cx = Math.cos(x);
	console.log("cos(n) = " + cx);
}
```

**문 블록**

- 블록은 세미콜론으로 끝나지 않는다. 블록 안에 있는 기본 문은 세미콜론으로 끝나지만 블록 자체는 그렇지 않다.
- 블록에 들어 있는 행은 자신을 감싼 중괄호를 기준으로 들여쓴다. 필수는 아니지만 이렇게 하면 코드를 읽고 이해하기 쉬워집니다.

표현식이 하위 표현식으로 구성될 수 있듯 문 역시 하위 문으로 구성될 수 있다.

자바스크립트 문법은 공식적으로 단일 하위 문을 허용한다. 예를 들어 while 루프 문법은 루프 바디로 기능하는 단일한 문을 포함한다. 문 블록을 사용하면 허용되는 하위 문 하나에 문 여러 개를 넣을 수 있다.

복합문은 자바스크립트가 문 하나를 예상하는 곳에 문 여러 개를 넣을 때 사용한다.

**빈 문**

빈 문은 반대이다. 문이 있을 것으로 예상되는 곳에 문을 쓰지 않을 수도 있다. 빈 문은 다음과 같이 작성한다.

```jsx
;
```

자바스크립트 인터프리터는 빈 문을 실행할 때 아무 일도 하지 않는다. 빈 문은 빈 바디를 갖는 루프를 만들고자 할 때 유용하다.

```jsx
// 배열 a를 초기화합니다.
for(let i = 0; i < a.length; a[i++] = 0) ;

if((a===0) || (b===0)); // 이 행은 아무 일도 하지 않습니다.
o = null; // 그리고 이 행은 조건과 상관없이 항상 실행됩니다.

// 빈 문을 사용할 때는 목적을 가지고 그렇게 했다는 것이 명확하도록 주석을 쓰는 것이 좋다.
for(let i = 0; i < a.length; a[i++] = 0) /* 의도적으로 비움. */ ;
```

## **제어문(control structure)**

자바스크립트 프로그램은 실행할 문의 모음에 지나지 않는다.

자바스크립트 인터프리터는 기본적으로 이런 문들을 작성된 순서대로 실행한다.

동작을 수행 하는 방법 중에는 기본 실행 순서를 바꾸는 것도 있다.

자바스크립트에는 이를 가능하게 하는 다양한 제어문이 있다.

## **조건문**

if나 switch처럼 자바스크립트 인터프리터가 표현식의 값에 따라 다른 문을 실행하거나 실행하지 않게 하는 문

### **if**

첫 번째 형태 

```jsx
if (expression) statement

if (username == null) // username이 null 또는 undefined이면
username = "JoHn Doe”; // 정의합니다.

// usernameol null, undefined, false, 0, NaN 중 하나이면 새 값을 할당합니다.
if (!username) username = "John Doe";
```

자바스크립트 문법은 if 키워드와 괄호로 둘러싼 표현식 뒤에 문 하나만 있어야 한다고 규정하지만, 문 블록을 써서  여러 문을 하나로 모을 수 있다.

```jsx
if (!address) {
	address = "";
	message = "Please specify a mailing address."; 
}
```

두 번째 형태

```jsx
if (expression)
	statement1
else
	statement2

if (n === 1)
	console.log("You have 1 new message.");
else
	console.log('You have ${n} new messages.');
```

```jsx
i = j = 1;
k = 2;
if (i === j)
	if (j === k)
		console.log("i equals k");
else
	console.log("i doesn't equal j");
```

- 해석 결과
    
    ```jsx
    if (i === j) {
    	if (j === k)
    		console.log("i equals k");
    	else
    		console.log("i doesn't equal j");
    }
    
    // 더 명확하게 써서 읽고, 이해하고, 관리하고, 디버그하기 쉽게 하려면
    // 다음과 같이 중괄호를 써야 합니다.
    
    if (i === j) {
    	if (j === k) {
    		console.log("i equals k");
    	}
    } else {
    	console.Log("i doesn't equal j");
    );
    ```
    

### else if

else if는 자바스크립트 문이 아니지만 if/else 문을 반복해 사 용해야 할 때 흔히 쓰는 관용적 표현이다.

```jsx
if (n === 1) {
// 코드 블록 #1을 실행합니다.
}
else {
	if (n === 2) {
		// 코드 블록 #2를 실행합니다.
	}
	else {
		if (n === 3) {
			// 코드 블록 #3을 실행합니다.
		}
		else {
			// 전부 실패하면 블록 #4를 실행합니다.
		}
	}
}

if (n === 1) {
	// 코드 블록 #1을 실행합니다.
} else if (n === 2) {
	// 코드 블록 #2를 실행합니다.
} else if (n === 3) {
	// 코드 블록 #3을 실행합니다.
} else {
	// 전부 실패하면 블록 #4를 실행합니다.
}
```

### switch

모든 분기점이 같은 표현식의 값에 좌우된다면 else if가 최선의 선택은 아니다. 똑같은 표현식을 여러 if 문이 반복해 평가하는 것은 낭비이다.

```jsx
switch(expression) {
	statements
}

switch(n) {
	case 1: // n === 1이면 여기서 시작합니다.
		// 코드 블록 #1을 실행합니다.
		break; // 여기서 멈춥니다.
	case 2: // n === 2이면 여기서 시작합니다.
		// 코드 블록 #2를 실행합니다.
		break; // 여기서 멈춥니다.
	case 3: // n === 3이면 여기서 시작합니다.
		// 코드 블록 #3을 실행합니다.
		break; // 여기서 멈춥니다.
	default: // 전부 실패하면...
		// 코드 블록 #4를 실행합니다.
		break; // 여기서 멈춥니다.
}

function convert(x) {
	switch(typeof x) {
		case "number": // 숫자를 16진수로 변환합니다.
			return x.toString(16); 
		case "string": // 문자열을 따옴표로 감싸 반환합니다.
			return '"' + x + '"';
		default: // 다른 타입은 일반적인 방법으로 변환합니다.
			return String(x); 
	}
}
```

switch 문에서 일치하는 케이스를 찾을 때는 동등 연산자 ==가 아니라 일치 연산자 ===을 사용한다.

switch 문을 실행할 때마다 case 표현식 전체가 평가되는 것은 아니므로 case 표현식에는 함수 호출이나 할당처럼 부수 효과가 있는 것은 피해야한다.

## 반복문, 루프

while이나 for처럼 다른 문을 반복적으로 실행하는 문

### while

if 문이 자바스크립트의 기본 조건문인 것과 마찬가지로 while 문은 자바스크립트의 기본 루프이다.

```jsx
while (expression)
	statement

let count = 0;
while(count < 10) {
	console.log(count);
	count++;
}
```

### do/while

do/while 루프는 while 루프와 비슷하지만 루프 표현식이 루프 맨 위가 아니라 맨 아래에서 평가된다는 점이 다르다. 따라서 루프 바디는 항상 최소 한 번은 실행된다.

```jsx
do
	statement
while (expression);

function printArray(a) {
	let len = a.length, i = 0;

	if (ten === 0) {
		console.log("Empty Array");
	} else {
		do {
			console.log(a[i]); 
		} while(++i < ten);
  } 
}

```

### for

for 문이 제공하는 루프 구조가 while 문보다 편리할 때가 많다. for 문은 널 리 쓰이는 패턴을 갖는 루프를 단순화한다.

대부분의 루프에는 어떤 형태로든 카운터 변수가 있다. 이 변수는 루프 시작 전에 초기화되고 루프가 반복될 때마 다 테스트된다. 마지막으로 루프 바디 끝에서 카운터 변수를 다시 테스트하기 직전에 증가시키거나 다른 방식으로 업데이트한다. 이런 루프에서 초기화, 테스트, 업데이트는 필수불가결한 동작이다.

for 문은 이 세 가지 동작을 표현식 하나로 묶고, 이들을 루프 문법에 명시적으로 포함한다.

```jsx
for(initialize ; test ; increment)
	statement

initialize;
while(test) {
	statement
	increment;
}

for(let count = 0; count < 10; count++) {
	console.log(count);
}

let i, j, sum = 0;
for(i = 0, j = 10 ; i < 10 ; i++, j—) {
	sum += i * j;
}

function tail(o) { // 연결된 리스트 o의 마지막을 반환합니다.
	for(; o.next; o = o.next) /* 비움 */ ; // o.next가 true 같은 값이면 반복합니다.
	return o;
}
```

### for/of

for/of는 ES6에서 정의한 새 반복문이다.

for/of 루프는 이터러블(iterable) 객체에서 동작한다.

```jsx
let data= [1, 2, 3, 4, 5, 6, 7, 8, 9], sum= 0;
for(let element of data) {
	sum += element; 
}
sum // => 45
```

**여기서 배열은 ‘동적으로’ 순회한다**. **즉 반복 중간에 배열 자체에 변화가 발생한다면 반복 결과가 바뀌기도 한다**. 만약 위 코드의 루프 바디에 data.push(sum) 라는 행을 추가한다면, 절대 배열의 마지막 요소에 도달할 수 없으므로 무한 루프가 만들어진다.

**for/of와 객체**

객체는 (기본적으로) 이터러블이 아니다.

객체의 프로퍼티를 순회하고 싶다면 for/in 루프를 사용하거나, Object.keys() 메서드에 for/of를 사용해야 한다.

```jsx
let o = { x: 1, y: 2, z: 3 };
for(let element of o) { // o는 이터러블이 아니므로 TypeError가 일어납니다.
	console.log(element);
}

let keys = "";
for(let k of Object.keys(o)) {
	keys += k;
}
keys // => "xyz"

let pairs = "";
for(let [k, v] of Object.entries(o)) {
	pairs += k + v;
}
pairs // => "xly2z3"
```

Object.keys()는 객체의 프로퍼티 이름으로 이루어진 배열을 반환하며 배열은 for/of를 사용할 수 있는 이터러블이다. **이렇게 객체의 키를 순회하는 것은 동적이지 않다. 루프 바디 안에서 객체 o를 변경해도 결과가 달라지지 않는다.**

Object.entries()는 배열의 배열을 반환한다. 그 내부 배열은 객체의 프로퍼티에 대응하는 키-값 쌍이다.

**for/of와 문자열**

ES6 이후에는 문자열을 다음과 같이 문자 단위로 순회할 수 있다.

```jsx
let frequency = {};
for(let letter of "mississippi") {
	if (frequency[letter]) {
		frequency[letter]++;
	} else {
		frequency[letter] = 1;
	} 
}
frequency // => {m: 1, i: 4, s: 4, p: 2}
```

문자열은 UTF-16 문자가 아니라 유니코드 코드 포인트로 순회한다. 이모지의 length는 2이지만 for/of로 순회하면 한 번 실행된다.

**for/of와 세트, 맵**

세트를 for/of로 순회하면 루프 바디는 세트의 각 요소에 대해 한 번씩 실행된다.

```jsx
let text = "Na na na na na na na na Batman!";
let wordSet = new Set(text.split(" "));
let unique = [];
for(let word of wordSet) {
	unique.push(word);
}
unique // => ["Na", "na", "Batman!"]
```

Map 객체의 이터레이터는 키나 값이 아닌 키-값 쌍을 순회한다. 반복할 때마다 이터레이터는 첫 번째 요소가 키, 두 번째 요소가 키에 대응하는 값인 배열을 반환한다.

```jsx
let m = newMap([[l, "one'*]]); 
for(let [key, value] of m) {
	key // => 1
	value // => "one" 
}
```

**for/await를 사용한 비동기 순회**

ES2018은 비동기 이터 레이터라는 새로운 이터 레이터를 도입하면서 비동기 이터 레이터와 함께 동작하도록 for/of 루프를 변형한 for/await 루프를 도입했다.

```jsx
// 스트림에서 비동기적으로 덩어리를 읽고 출력합니다.
async function printStream(stream) {
	for await (let chunk of stream) {
		console.log(chunk); 
	}
}
```

### for/in

for/of 루프는 of 다음에 이터러블 객체가 와야하지만 for/in 루프는 in 다음에 어떤 객체든 쓸 수 있다. for/of 루프는 ES6에서 새로 도입했지만 for/in 는 자바스크립트 초창기부터 존재했다.

```jsx
for (variable in object)
	statement

for(let p in o) { // o의 프로퍼티 이름를 변수 P에 할당합니다.
	console.log(o[p]); // 각 프로퍼티 값을 출력합니다.
}
```

자바스크립트 인터프리터는 for/in 문을 실행할 때 첫 번째로 object 표현식을 평가한다. 그 표현식이 null이나 undefined로 평가되면 인터프리터는 루프를 건너뛰고 다음 문으로 이동한다. 그렇지 않으면 인터프리터는 객체의 열거 가능한 (enumerable) 프로퍼티 각각에 한 번씩 루프 바디를 실행한다. 하지만 각 반복에 앞서 인터프리터는 variable 표현식을 평가하고 그 변수에 프로퍼티 이름(문자열 값)을 할당한다.

for/in 루프의 variable은 왼쪽 값으로 평가될 수만 있다면 어떤 표현식을 써도 된다. 이 표현식은 루프를 반복할 때마다 평가되므로 매번 다른 값이 될 수도 있다.

```jsx
let o = { x: 1, y: 2, z: 3 };
let a = [], i = 0;
for(a[i++] in o) {} // 빈 것이 맞습니다.
a // => ['x', 'y', 'z']

for(let i in a) console.log(a[i]);
```

자바스크립트 배열은 좀 특별한 종류의 객체이며 배열 인덱스는 for/in 루프에서 열거할 수 있는 객체 프로퍼티이다. 배열을 대상으로 작업할 때는 거의 항상 for/in이 아니라 for/of가 맞는 루프이다.

for/in 루프는 실제로 객체의 프로퍼티 전체를 열거하지 않는다.

- 이름이 심벌인 프로퍼티는 열거하지 않는다. 이름이 문자열인 프로퍼티 중에서도 열거 가능한 프로퍼티만 순회한다.
- 자바스크립트에서 정의하는 내장 메서드는 열거 가능하지 않는다. 모든 객체에 toString() 메서드가 있지만 for/in 루프는 toString 프로퍼티를 열거 대상으로 간주하지 않는다.
- 내장 객체에는 내장 메서드 외에도 열거 불가능한 프로퍼티가 많다. 직접 정의한 프로퍼티와 메시드는 기본적으로 열거 가능하다
- 열거 가능한 상속된 프로퍼티 역시 for/in 루프의 순회 대상에 속한다. 따라서 모든 객체에서 상속하는 프로퍼티를 정의하고 for/in 루프를 사용한다면 결과가 예상과 다를 수 있다.

이 때문에 많은 프로그래머가 for/in 루프 대신 Object.keys()와 for/of 루프를 조합하길 선호한다.

for/in 루프의 바디에서 아직 열거되지 않은 프로퍼티를 삭제한다면 그 프로퍼티는 순회 대상에서 빠진다. 루프 바디에서 객체에 새 프로퍼티를 정의한다면 그 프로퍼티는 순회 대상에 있을 수도 있고 없을 수도 있다.