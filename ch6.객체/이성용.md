# 6장 객체

## 객체 소개

객체는 복합된 값이다. 객체는 여러 가지 값(기본 값이나 다른 객체)을 모아서 이름을 통해 값을 저장하고 가져올 수 있게 한다.

자바스크립트 객체는 자신만의 프로퍼티를 가지는 것 외에도, ‘프로토타입’으로 불리는 다른 객체에 서 프로퍼티를 상속하기도 한다. 객체의 메서드는 일반적으로 상속된 프로퍼티이며 이 '프로토타입 상속’이 자바스크립트의 중요한 기능이다.

자바스크립트 객체는 동적이기 때문에 일반적으로 프로퍼티를 추가하거나 삭제 할 수 있지만, 정적인 객체를 흉내 낼 수도 있고 정적 타입을 사용하는 언어의 구조 역시 사용할 수 있다.

자바스크립트에서 문자열, 숫자, 심벌, true, false, null, undefined가 아닌 값은 전부 객체이다. 또한 문자열, 숫자, 불은 객체가 아니지만 불변인 객체처럼 행동 할 수도 있다.

**프로퍼티**

프로퍼티에는 이름과 값이 있다. 프로퍼티 이름에는 빈 문자열과 심벌을 포함해 어떤 문자열이든 쓸 수 있지만, 같은 이름의 프로퍼티는 존재할 수 없다. 값은 타입을 가리지 않는 자바스크립트 값이며 게터(getter)나 세터(setter), 또는 둘 다가 될 수도 있다.

객체에서 직접 정의한 프로퍼티와 프로토타입 객체에서 상속한 프로퍼티를 구별 하는 것이 중요할 때도 있다. 자바스크립트에서는 상속되지 않은 프로퍼티를 가리켜 자체 프로퍼티(own property)라고 부른다.

모든 프로퍼티에는 이름과 값 외에도 다음과 같은 세 가지 프로퍼티 속성이 있다.

- 쓰기 가능(writable) - 프로퍼티에 값을 설정할 수 있는지 없는지를 나타낸다.
- 열거 가능(enumerable) - for/in 루프에 프로퍼티 이름을 반환할지 안 할 지를 나타낸다.
- 변경 가능(configurable) - 프로퍼티를 삭제할 수 있는지 없는지, 속성을 바꿀 수 있는지 없는지를 나타낸다.

자바스크립트 내장 객체의 프로퍼티 중 상당수는 읽기 전용이기나 얼기 불가이거나 변경 불가이다. 보통 직접 만드는 객체의 프로퍼티는 기본적으로 쓰기 가능, 열거 가능, 변경 가능이다.

## 객체 생성

### 객체 리터럴

객체를 생성하는 가장 쉬운 방법이다.

```jsx
let empty = {}; // 프로퍼티가 없는 객체
let point = { x: 0, y: 0 }; // 숫자 프로퍼티 두 개
let p2 = { x: point.x, y: point.y+1 }; // 좀 더 복잡한 값
let book = {
	"main title": "JavaScript", // 이 프로퍼티 이름에는 스페이스와 하이픈이
	"sub-title": "The Definitive Guide" // 들어 있으므로 문자열 리터럴을 썼습니다.
	for: "all audiences", // for는 예약어이지만 따옴표를 쓰지 않았습니다.
	author: { // 이 프로퍼티의 값은 객체입니다.
		firstname: "David", surname: "Flanagan" 
	}
};
```

객체 리터럴의 마지막 프로퍼티 뒤에 콤마를 쓸 수 있다.

객체 리터럴을 평가할 때마다 새 객체가 만들어진다. 각 프로퍼티의 값 역시 리터럴을 평가할 때마다 평가된다. 따라서 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프 바디 안에 있다면 새 객체를 여러 개 만들 수 있으며, 이 객체들의 프로퍼티 값 역시 매번 달라질 수 있다.

### new

```jsx
let o = new Object(); // 빈 객체를 만듭니다. {}와 같습니다.
let a = new Array(); // 빈 배열을 만듭니다. []와 같습니다.
let d = new Date(); // 현재 시간을 나타내는 Date 객체를 만듭니다.
let r = new Map(); // 키와 값을 연결하는 Map 객체를 만듭니다.
```

new 연산자는 새 객체를 생성하고 초기화한다. new 키워드 뒤에는 반드시 함수 호출이 있어야 한다. 이런 형태로 사용하는 함수를 생성자라고 부르고, 새로 생성된 객체를 초기화하는 목적으로 사용한다. 자바스크립트의 내장 타입에도 생성자가 있다.

### 프로토타입

[ProtoType](https://www.notion.so/ProtoType-4cc8837987424b918c3454fe0692afcb)

자바스크립트 객체 거의 대부분은 자신과 연결된 두 번째 객체를 갖는다. 여기서 두 번째 객체를 프로토타입이라 부르며, 첫 번째 객체는 프로토타입에서 프로퍼티를 상속한다.

객체 리터럴을 사용해 생성한 객체는 모두 같은 프로토타입 객체를 갖는다. 그리고 이 프로토타입 객체는 Object.prototype이라는 코드로 참조할 수 있다. new 키워드와 생성자를 사용해 만든 객체는 생성자 함수의 prototype 프로퍼티 값을 자신의 프로토타입으로 사용한다.

```jsx
new Object() // Object.prototype
new Array() // Array.prototype
new Date() // Date.prototype
```

거의 모든 객체에 프로토타입이 있지만, prototype 프로퍼티가 있는 객체는 비교적 적다. prototype 프로퍼티를 갖는 객체가 다른 객체의 프로토타입을 정의한다.

Object.prototype은 프로토타입이 없는 드문 객체 중 하나이다. 이 객체는 어떤 프로퍼티도 상속하지 않다.

프로토타입 객체 사이의 연결을 프로토타입 체인이라 부른다.

### Object.create()

```jsx
let o1 = Object.create({x: 1, y: 2}); // o1은 x와 y 프로퍼티를 상속합니다.
o1.x + o1.y // => 3
let o2 = Object.create(null); // o2는 프로퍼티나 메서드를 상속하지 않습니다. 기본 메서드조차 없습니다.
let o3 = Object.create(Object.prototype); // o3는 {}나 new Object()와 같습니다.

let o = { x: "don't change this value" };
library.function(Object.create(o)); // 의도치 않은 변경에 대한 방어
```

## 프로퍼티 검색과 설정

```jsx
let author = book.author; // book의 author 프로퍼티를 가져옵니다.
let name = author.surname; // author의 surname 프로퍼티를 가져옵니다.
let title = book["main title"]; // book의 main title 프로퍼티를 가져옵니다.
```

```jsx
book.edition = 7; // book에 edition 프로퍼티를 만듭니다.
book["main title"] = "ECMAScript"; // main title 프로퍼티를 변경합니다.
```

### 연관 배열인 객체

```jsx
object.property // 식별자
object["property"] // 연관배열
```

연산자를 사용해 객체 프로퍼티에 접근할 때 프로퍼티 이름은 식별자로 표현된다. 식별자는 반드시 문자 그대로 프로그램에 입력해야 한다. 식별자는 데이터 타입이 아니므로 프로그램에서 조작할 수 없다.

대괄호 연산자로 객체 프로퍼티에 접근할 때는 프로퍼티 이름을 문자열로 표현한다. 문자열은 자바스크립트 데이터 타입이므로 프로그램이 실행되는 동안 새로 생성할 수도 있고 조작할 수도 있다.

```jsx
let addr = "";
for (let i = 0; i < 4; i++) {
	addr += customer [`address${i}`] + "\n";
}

function addstock(portfolio, stockname, shares) {
	portfolio[stockname] = shares;
}

function computeValue(portfolio) {
	let total = 0.0;
	for(let stock in portfolio) {
		let shares = portfolio[stock];
		let price = getQuote(stock);
		total += shares * price;
	}
	return total;
}
```

프로그램을 만들 때 프로퍼티 이름을 알지 못하기 때문에 점 연산자를 써서는 portfolio 객체의 프로퍼티에 접근할 수 없다. 하지만 대괄호 연산자는 정적이 고 반드시 프로그램에 있는 그대로 써야 하는 식별자가 아니라, 동적이고 런타임에 바꿀 수 있는 문자열 값을 사용하므로 이런 상황에도 쓸 수 있다.

### 상속

```jsx
let o = {}; // o는 Object.prototype에서 객체 메서드를 상속합니다.
o.x = 1; // 이제 자체 프로퍼티 x가 생겼습니다.
let p = Object.create(o); // p는 o와 Object.prototype에서 프로퍼티를 상속합니다.
p.y = 2; // 자체 프로퍼티 y가 생겼습니다.
let q = Object.create(p); // 이는 p, o, Object.prototype에서 프로퍼티를 상속합니다.
q.z = 3; // 자체 프로퍼티 q가 생겼습니다.
let f = q.toString(); // toString은 Object.prototype에서 상속했습니다.
q.x + q.y // => 3; x와 y는 o와 아에서 상속했습니다.
```

```jsx
let unitcircle = { r: 1 }; // 상속할 객체
let c = Object.create(unitcircle); // c는 프로퍼티（을 상속합니다.
c.x = 1; c.y = 1; // c에 자체 프로퍼티 두 개를 정의합니다.
c.r = 2; // c가 상속한 프로퍼티를 덮어 씁니다.
unitcircle.r // => 1: 프로토타입은 영향받지 않습니다.
```

### 프로퍼티 접근 에러

```jsx
book.subtitle // => undefined: 프로퍼티가 존재하지 않습니다.
let len = book.subtitle.length; // TypeError: undefined에는
// length 프로퍼티가 없습니다.

// 장황하지만 명시적인 방법
let surname = undefined;
if (book) {
	if (book.author) {
		surname = book.author.surname;
	}
}

// surname, null, undefined 중 하나를 가져오는 간결하고 관용적인 방법
let surname = book && book.author && book.author.surname;
let surname = book?.author?.surname;
```

null이나 undefined의 프로퍼티를 설정하려 해도 TypeError가 일어난다. 

다른 값에 프로퍼티를 설정하려 해도 항상 성공하는 것은 아니다. 읽기 전용인 프로퍼티 일 수도 있고, 객체가 프로퍼티 추가를 허용하지 않을 수도 있다. 아래와 같은 경우 스트릭트 모드에서는 프로퍼티를 설정하려다 실패하면 TypeError가 일어나고 스트릭트 모드가 아니라면 보통 조용히 실패한다.

**o에 자체 프로퍼티 p가 있고 읽기 전용일 때**

읽기 전용 프로퍼티의 값은 바꿀 수 없다.

**o에 상속된 프로퍼티 p가 있고 읽기 전용일 때**

상속된 읽기 전용 프로퍼티를 같은 이름의 자체 프로퍼티로 가릴 수 없다.

**o에 자체 프로퍼티 p가 없으며 세터 메서드로 프로퍼티 p를 상속하지 않고 o의 확장 가능(extensible) 속성이 false일 때**

p는 o에 존재하지 않고 호출 할 세터 메서드도 없으므로 p를 o에 추가해야 하지만, o는 확장 불가이므로 새 프로퍼티를 정의할 수 없다.