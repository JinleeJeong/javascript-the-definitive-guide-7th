# 6장 객체

## 6.1 객체 소개

객체는 프로퍼티와 '프로토타입' 으로 불리는 다른 객체어서 프로퍼티를 상속하기도 함

객체는 동적이지만, 정적인 객체를 흉내 낼 수 있음

문자열 세트를 표현하는데도 사용할 수 있음


기본 타입 `문자열, 숫자, 심벌, true, false, null, undefined` 외에는 전부 객체

`문자열, 숫자, 불` 은 객체가 아니지만 불변인 객체처럼 행동할 수 있음 (???)


상속되지 않은 프로퍼티는 자체 프로퍼티(own property) 라고 부름

모든 프로퍼티에는 아래와 같은 속성이 있음

- 쓰기 가능
	- 프로퍼티에 값을 설정할 수 있는지 없는지를 나타냄
- 열거 가능
	- `for/in` 루프에 프로퍼티 이름을 반환할지 안할지를 나타냄
- 변경 가능
	- 프로퍼티를 삭제할 수 있는지 없는지, 속성을 바꿀 수 있는지 없는지를 나타냄


자바스크립트의 내장 객체의 프로퍼티 중 상당수는 읽기 전용이거나 열거 불가, 변경 불가임

직접 만드는 객체의 프로퍼티는 기본적으로 쓰기, 열거, 변경 가능임



## 6.2 객체 생성

### 6.2.1 객체 리터럴

```
let p2 = { x: point.x, y: point.y+1 };
```

`이름: 값`  형태의 쌍을 중괄호로 감싼 형태

프로퍼티 값은 자바스크립트 표현식이면 모든 가능



객체 리터럴이 평가될 때마다 새 객체가 만들어지고, 각 프로퍼티의 값 역시 리터럴이 평가될 때마다 평가 됨

**따라서 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프 바디 안에 있다면 새 객체를 여러 개 만들 수 있고, 각 프로퍼티의 값도 매번 달라질 수 있음**



### 6.2.2 new

새 객체를 생성하고 초기화 하는  `new`  키워드는 뒤에는 함수 호출이 있어야 함, 이러한 형태로 사용하는 함수를 생성자라 부름


### 6.2.3 프로토타입

객체는 거의 대부분 자신과 연결된 두 번째 객체를 갖고, 이 객체를 프로토타입이라 부름

첫 번째 객체는 프로토타입에서 프로퍼티를 상속함


객체 리터럴을 사용해 생성한 객체는 모두 같은 프로토타입 객체를 갖음, 이 프로토타입 객체는 `Object.prototype` 이라는 코드로 참조 가능


`new` 키워드와 생성자를 사용해 만든 객체는 생성자 함수의 `prototype` 값을 자신의 프로토타입으로 사용


따라서, `new Object()` 로 생성한 객체는 `{}` 로 생성한 객체와 마찬가지로 `Object.prototype` 에서 상속함

`Object.prototype` 은 프로토타입이 없는 객체 중 하나 (...?? 무슨 말임)

내장 생성자 대부분에 `Object.prototype` 에서 프로퍼티를 상속하므로 `new Date()` 로 생성한 `Date` 객체는 `Date.prototype, Object.prototype` 양쪽에서 상속 받음

이렇게 이어지는 프로토타입 객체 사이의 연견을 **프로토타입 체인** 이라 부름




### 6.2.4 Object.create()

첫 번째 인자를 프로토타입 삼아 새 객체를 생성 함

```
let o1 = Object.create({x: 1, y: 2 });
```

```
let o2 = Object.create(null);
```

`null` 을 인자로 프로토타입이 없는 객체를 생성하면 아무것도 상속하지 않으며, `toString()` 과 같은 기본 메서드도 없음

`{}, new Object()` 같은 일반적인 빈 객체는 아래와 같이 생성함

```
let o3 = Object.create(Object.prototype);
```



`Object.create()` 사용하는 목적 중 하나는 서드 파티 라이브러리에서 객체를 변경하는 사고를 막는 것


```
let o = { x: "don't change this value" }; library.function(object.create(o)); // 의도치 않은 변경에 대한 방어
```



## 6.3 프로퍼티 검색과 설정

### 6.3.1 연관 배열인 객체

런타임에 프로퍼티이름을 알 수 있는 경우는 대괄호로 프로퍼티를 접근함

```
function addstock(portfolio, stockname, shares) { 
	portfolio [stockname] = shares;
}
```



### 6.3.2 상속


객체 o의 x 프로퍼티를 가져오는 경우 o에 x라는 자체 프로퍼티가 없으면 프로토타입 객체에서 x 프로퍼티를 검색하고, 프로토타입 객체에도 없지만 프로토타입이 있다면 프로토타입의 프로토타입에서 해당 프로퍼티를 검색함, x 
 프로퍼티를 찾거나, 프로토타입이 `null` 인 객체에 도달할 때까지 검색함 (undefined는???)



객체 o의 x 프로퍼티에 값을 할당하는 경우 o에 이미 자체 x 프로퍼티가 있다면 기존 프로퍼티의 값을 바꿈

없다면, 객체 o에 x 프로퍼티를 새로 만들고 할당함

o에 상속된 프로퍼티 x가 있었다면, 상속된 프로퍼티는 새로 생성된 자체 프로퍼티에 가려짐

프로퍼티 할당은 프로토타입 체인을 검색해 할당이 허용되는지 확인, 읽기 전용인 x 프로퍼티를 상속한다면 할당은 허용되지 않음


하지만, 할당이 허용된다면 원래 객체에 프로퍼티를 생성하거나 설정할 뿐, 프로토타입 체인에 존재하는 객체는 절대 수정하지 않음


프로퍼티 검색할 때는 상속을 감안하지만, 설정할 때는 그렇지 않으므로 상속된 프로퍼티도 덮어 쓸 수 있음

```
let unitcircle = {r:1}; // 상속할 객체
let c = Object.create(unitcircle); // c는 프로퍼티 r을 상속합니다.
C.x = 1; c.y = 1; // c에 자체 프로퍼티 두 개를 정의합니다.
c. r = 2; // c가 상속한 프로퍼티를 덮어 씁니다.
unitcircle.r // => 1: 프로토타입은 영향받지 않습니다.
```



프로퍼티 할당은 실패하거나, 원래 객체에 프로퍼티를 생성 또는 설정한다는 규칙에는 예외가 있음, o가 x 프로퍼티를 상속하고 그 프로퍼티가 세터 메서드가 있는 접근자 프로퍼티라면 o에 x 프로퍼티를 새로 만드는 대신 세터 메서드를 호출함, 하지만 이 세터 메서드는 객체 o에서 호출되기 때문에 프로토타입 체인은 변하지 않음


### 6.3.3 프로퍼티 접근 에러

프로퍼티를 검색하면서 없는 프로퍼티를 검색하는 경우 `null, undefined` 이면 `TypeError` 이기 때문에 아래와 같이 `ES2020` 에서 지원하는 조건부 프로퍼티 접근 연산자를 이용할 수 있음

```
let surname = book?.author?.surname;
```

`null, undefined` 의 프로퍼티를 설정하려 해도 `TypeError` 가 일어남

읽기 전용 프로퍼티 이거나, 객체가 프로퍼티 추가를 허용하지 않는 경우 `TypeError` 가 일어남

예로, 객체 o에 프로퍼티 p를 설정하려하다 실패하는 경우

- o에 자체 프로퍼티 p가 있고 읽기 전용일 때: 읽기 전용 프로퍼티의 값은 바꿀 수 없습니다
- o에 상속된 프로퍼티 p가 있고 읽기 전용일 때: 상속된 읽기 전용 프로퍼티를 같 은 이름의 자체 프로퍼티로 가릴 수 없습니다.
- o에 자체 프로퍼티 p가 없으며 세터 메서드로 프로퍼티 p를 상속하지 않고 o의 확장 가능 속성이 `false` 일 때: p는 o에 존재하지 않고 호출 할 세터 메서드도 없으므로 p를 o에 추가해야 하지만, 이는 확장 불가이므로 새 프로퍼티를 정의할 수 없습니다.


## 6.4 프로퍼티 삭제

`delete`  연산자로 프로퍼티를 삭제할 수 있음, 값을 삭제하는 것이 아니라 프로퍼티 자체를 삭제함

상속된 프로퍼티는 삭제하지 않음

상속된 프로퍼티를 삭제하려면 해당 프로퍼티를 정의한 프로토타입 객체에서 삭제해야 함

변경 가능 속성이 `false` 인 프로퍼티는 제거하지 않음

변경 불가 프로퍼티를 삭제하려 하면 `TypeError` 

## 6.5 프로퍼티 테스트

`in, hasOwnProperty(), propertyIsEnumerable()` 메서드를 사용

```
let o = { x: 1 };
"x" in o // => true
o.hasOwnProperty("x") // => true
o.propertyIsEnumerable("x") // => true 열거 가능함
```

일반적인 자바스크립트 코드로 생성한 프로퍼티는 모두 열거 가능

`in`  대신 `!==` 을 사용하여 `undefined` 가 아님을 확인하는 경우도 있음

`in`  은 존재하지만 값이 `undefined` 인 프로퍼티를 구분 가능

```
let o = { x: undefined };
o.x !== undefined // => false
"x" in o // => true
```

## 6.6 프로퍼티 열거

객체의 프로퍼티 이름을 배열에 저장해서 `for/of` 루프를 사용하는 것이 쉬움

- `Object.keys()` 객체의 열거 가능한 자체 프로퍼티 이름을 배열로 반환함, 열거 불가, 상속된 프로퍼티, 이름이 심벌인 프로퍼티는 내보내지 않음
- `Object.getOwnPropertyNames()` 이름이 문자열이기만 하면 열거 불가인 자체 프로퍼티 이름도 배열로 반환
- `Object.getOwnPropertySymbols()` 열거 가능 여부를 따지지 않고 이름이 심벌인 자체 프로퍼티를 배열로 반환
- `Reflect.ownKeys()` 열거 가능 여부를 따지지 않고, 문자열인지 심벌인지 구분하지않고 자체 프로퍼티 이름은 전부 배열로 반환



### 6.6.1 프로퍼티 열거 순서

- 이름이 음이 아닌 정수인 문자열 프로퍼티가 첫 번째로 나열되며 작은 수에서 큰 수 순으로 열거됩니다. 따라서 배열 및 배열 비슷한 객체의 프로퍼티도 순서 대로 열거됨
- 배열 인덱스와 비슷한 프로퍼티를 모두 열거한 다음에는 음수나 부동 소수점 숫자처럼 보이는 프로퍼티를 포함해 이름이 문자열인 프로퍼티를 열거합니다. 이 프로퍼티는 객체에 추가된 순서대로 열거됨, 객체 리터럴로 정의된 프로퍼 티는 리터럴에 쓰인 순서를 따름
- 이름이 심벌인 프로퍼티를 객체에 추가된 순서대로 열거


같은 이름의 프로퍼티가 이미 열거 되었다면 열거하지 않으며, 이미 고려된 프로퍼티 중 같은 이름의 열거 불가 프로퍼티가 있었다면 열거하지 않음


## 6.7 객체 확장

`Object.assign()` 으로 객체를 확장할 수 있음, 첫 번째 인자는 수정해서 반환할 대상 객체, 두 번째는 소스 객체이므로 수정하지 않음

심벌을 포함해 대상 객체에 복사하며, 인자 순서대로 처리하고, 두 번째 소스 객체가 있다면 첫 번째 객체에 같은 이름의 프로퍼티를 덮어씀

```
function merge(target, ...sources) {
	for(let source of sources) {
		for(let key of Object. keys (source)) { 
			if (!(key in target)) { // Object.assign()과 다른 점입니다. 
				target [key] = source [key];
			}
		}
	}
	return target;
}

Object.assign({x: 1}, {x: 2, y: 2}, {y: 3, z: 4}) // => {x: 2, y: 3, z: 4}
merge({x: 1}, {x: 2, y: 2}, {y: 3, z: 4}) // => {x: 1, y: 2, z: 4}
```

## 6.8 객체 직렬화

객체를 문자열로 변환하는 작업

```
let o = {x: 1, y: {z: [false, null, "]}}; // 테스트 객체를 정의합니다. let s = JSON.stringify(o); // s == '{"x":1, "y":{"z": [false, null,""]}}'
let p = JSON.parse(s); // p == {x: 1, y: {z: [false, null, ""]}}
```

`NaN, Infinity, -Infinity` 는 `null` 로 직렬화 됨

`Date` 객체는 `ISO`  형식 날짜 문자열로 직렬화 되지만 (Date.toJSON()) `JSON.parse()` 는 이 문자열을 그대로 문자열로 둘 뿐 `Date` 객체로 복원하지 않음


`함수, RegExp, Error, undefined` 는 직렬화하거나 복원할 수 없음

직렬화 할 수 없는 프로퍼티는 문자열에서 생략됨



## 6.9 객체 메서드

### 6.9.1 toString() 메서드

`toString()` 자체는 별로 도움이 되지 않으며, `toString()` 을 재정의해 유용하게 사용 가능

```
let o = {
	x: 1,
	y: 2,
	toString(): function() { return `(${this.x}, ${this.y})`; }
};

String(point) // => "(1, 2)" 문자열로 변환할 때 toString()을 호출함
```

### 6.9.2 toLocaleString() 메서드

지역에 맞는 문자열을 표현하며 일반적인 객체는 지역화 기능이 없어 그저 `toString()` 을 호출해 값을 반환함

`Date` 와 숫자 클래스에는 지역에 맞게 표현하는 `toLocaleString()` 이 있음, 배열의 경우 `toString()` 과 비슷하게 갖고 있지만 `toLocaleString()` 메서드를 호출한다는 점이 다름



### 6.9.3 valueOf() 메서드

문자열이 아닌 기본 타입, 보통은 숫자로 변환하려 할 때 호출함

기본 값을 예상하는 곳에 객체를 사용하면 자동으로 이 메서드를 호출함

`Number(x)` 와 같은 경우 `valueOf()` 가 호출 됨

### 6.9.4 toJSON() 메서드

`Object.prototype` 에 `toJSON()` 이 정의 된 것은 아니지만 `JSON.stringify()` 메서드는 직렬화할 객체에서 `toJSON()` 메서드를 검색하고, 존재한다면 해당 메서드를 호출해 반환 값을 직렬화함



## 6.10 확장된 객체 리터럴 문법

### 6.10.1 단축 프로퍼티

변수에 값을 저장하고 객체에서 변수 이름으로 프로퍼티를 만들고 값을 할당하고 싶다면 아래와 같이 가능함

```
let x = 1, y =2;
let o = { x, y };
o.x + o.y // => 3
```


### 6.10.2 계산된 프로퍼티 이름

컴파일 타임 상수가 아니라 변수에 저장되어 있거나 함수의 반환 값으로 프로퍼티 이름을 정하고 싶을 때 아래와 같이 할 수 있음

```
const PROPERTY_NAME = "p1";
function computePropertyName() {
	return "p" + 2;
}
let p = {
	[PROPERTY_NAME] : 1,
	[computePropertyName()]: 2
};
p.p1 + p.p2 // => 3
```


### 6.10.3 프로퍼티 이름인 심벌

계산된 프로퍼티 이름을 심벌을 이용해 사용할 수 있음

```
const extension = Symbol("my extension symbol");
let o = { [extension]: { /* 이 객체에 확장 데이터를 저장합니다. */ } o[extension].x = 0; // o의 다른 프로퍼티와 충돌하지 않습니다.
```

심벌을 자체적으로 고유하기 때문에, 서드 파티 코드에서 가져온 객체에 프로퍼티를 추가하는 경우 다른 프로퍼티와 추가 하고싶은 경우 유용함

### 6.10.4 분해 연산자

```
let position = { x: 0, y: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ... position, ...dimensions };
rect.x + rect.y + rect.width + rect.height // => 175
```

`ES2018` 이후 객체 리터럴 안에서  분해 연산자 `...` 를 통해 기존 객체의 프로퍼티를 새 객체에 복사할 수 있음


분해 되는 객체와 프로퍼티를 받는 객체 둘 다 같은 이름의 프로퍼티를 갖는다면 해당 프로퍼티의 값은 마지막에 오는 값이 됨
```
let o = { x: 1 };
let p = { x: 0, ...0 }; // => 1: 객체 0의 값이 초깃값을 덮어 씁니다.
p.x // => 1
let q = { ...0, X: 2 };
q.x // => 2
```


상속된 프로퍼티에는 적용되지 않음


```
let o = Object.create({x: 1}); // 0는 프로퍼티 x를 상속합니다.
let p = { ...0 };
p.X // => undefined
```

`...` 는 자바스크립트 인터프리터가 객체의 프로퍼티  `n` 개를 다른 객체로 분해하는 작업은 `O(n)` 임, 따라서 루프나 재귀함수에 넣어 사용한다면 `n` 이 커질수록 `O(p^2)` 알고리즘을 쓰게 됨


### 6.10.5 단축 메서드

객체 프로퍼티로 정의된 함수는 메서드라 부름

`ES6` 전에는 객체 리터럴 안에 함수 정의 표현식을 써서 메서드를 정의 했음

```
let square = {
	area: function() { return this.side * this.side; },
	side: 10
};
square.area() // => 100
```

`ES6` 에서 객체 리터럴 문법에서 `function` 키워드와 콜론을 생략할 수 있으므로 아래와 같이 사용 가능

```
let square = {
	area() { return this.side * this.side; },
	side: 10
};
square.area() // => 100
```


일반적인 식별자 외에도 문자열 리터럴, 계산된 프로퍼티 이름, 심벌도 사용 가능

메서드 이름에 심벌을 사용하는 이유는 `for/of` 루프에서 사용하도록 이터러블로 만들기 위해 사용하는 경우

### 6.10.6 프로퍼티 게터와 세터

프로퍼티값을 조회 하거나 설정할 때 게터와 세터를 호출함

프로퍼티에 게터 메서드만 있으면 읽기 전용이며, 세터 메서드만 있다면 쓰기 전용이고 값을 읽으려 하면 `undefined` 로 평가됨


```
let o = {
	// 일반적인 데이터 프로퍼티
	dataProp: value,
	// 함수의 쌍으로 정의된 접근자 프로퍼티
	get accessorProp() { return this.dataProp; },
	set accessProp(value) { this.dataProp = value; }
};
```

접근자 프로퍼티도 상속되므로 다른 객체의 프로토타입으로 사용 가능

접근자 프로퍼티는 프로퍼티에 쓸 때 유효성 검사, 읽을 때마다 다른 값을 반환하는 방법으로도 사용

## 6.11 요약

- 열거 가능, 자체 프로퍼티 같은 객체 용어
- `ES6` 이후에 추가된 객체 리터럴 문법
- 객체의 프로퍼티를 읽고, 쓰고, 삭제하고, 열거하고, 확인하는 방법
- 프로토타입 기반 상속이 동작하는 방법, `Object.create()` 를 통해 다른 객체를 상속하는 객체를 만드는 방법
- `Object.assign()` 통해 다른 객체로 프로퍼티를 복사하는 방법
